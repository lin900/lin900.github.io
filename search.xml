<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>SQL介绍</title>
      <link href="/2024/06/23/SQL%E4%BB%8B%E7%BB%8D/"/>
      <url>/2024/06/23/SQL%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="SQL介绍"><a href="#SQL介绍" class="headerlink" title="SQL介绍"></a>SQL介绍</h2><h3 id="SQL数据定义"><a href="#SQL数据定义" class="headerlink" title="SQL数据定义"></a>SQL数据定义</h3><h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><p>SQL支持类型</p><ul><li>char（n）</li><li>varchar(n)</li><li>int</li><li>smallint</li><li>numeric(p,d)</li><li>real double precision</li><li>float(n)<br>两个char比较时，自动追加空格使得长度相等</li></ul><h4 id="基本模式定义"><a href="#基本模式定义" class="headerlink" title="基本模式定义"></a>基本模式定义</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> department</span><br><span class="line">(   dept_name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">    building  <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">    budget    <span class="type">numeric</span>(<span class="number">12</span>,<span class="number">2</span>),</span><br><span class="line">    primary_key(dept_name);</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>完整性约束</p><ul><li>primary_key（A1,A2，…）</li><li>foreign_key（A1,A2，…）references s</li><li>not null</li></ul><p>SQL禁止破坏完整性约束的数据库更新，如主码出现空值，主码相同</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">drop table r1//删除关系</span><br><span class="line">delete table r1//删除关系中的元组</span><br><span class="line">alter table r add A D //A为属性名 D为属性类型</span><br><span class="line">alter table r drop A 删除属性</span><br></pre></td></tr></table></figure><h3 id="SQL查询基本结构"><a href="#SQL查询基本结构" class="headerlink" title="SQL查询基本结构"></a>SQL查询基本结构</h3><h4 id="单关系查询"><a href="#单关系查询" class="headerlink" title="单关系查询"></a>单关系查询</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name</span><br><span class="line"><span class="keyword">from</span> instructor;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>强制去重</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> dept_name</span><br><span class="line"><span class="keyword">from</span> instructor;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>显式不去重</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">all</span> dept_name</span><br><span class="line"><span class="keyword">from</span> instructor;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>加入运算符，不改变数据库</span><br><span class="line"><span class="keyword">select</span> ID，name，dept_name,salary<span class="operator">*</span><span class="number">1.1</span> <span class="keyword">as</span> A</span><br><span class="line"><span class="keyword">from</span> instructor;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>加入逻辑连词 <span class="keyword">and</span> <span class="keyword">or</span> <span class="keyword">not</span></span><br><span class="line"><span class="keyword">select</span> name</span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">where</span> dept_name<span class="operator">=</span><span class="string">&#x27;Comp.Sci&#x27;</span><span class="keyword">and</span> salary<span class="operator">&gt;</span><span class="number">7000</span>;</span><br></pre></td></tr></table></figure><h4 id="多关系查询"><a href="#多关系查询" class="headerlink" title="多关系查询"></a>多关系查询</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name,instructor.dept_name,building</span><br><span class="line"><span class="keyword">from</span> instructor,department</span><br><span class="line"><span class="keyword">where</span> instructor.dept_name<span class="operator">=</span>department.dept_name;</span><br></pre></td></tr></table></figure><p>SQL查询理解（实际不会这么做）</p><ul><li>为from子句列出的关系生成笛卡尔积</li><li>应用where语句</li><li>输出select属性</li></ul><p>实际只产生满足where语句的笛卡尔积元素</p><h3 id="附加的基本运算"><a href="#附加的基本运算" class="headerlink" title="附加的基本运算"></a>附加的基本运算</h3><h4 id="更名运算"><a href="#更名运算" class="headerlink" title="更名运算"></a>更名运算</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">old</span><span class="operator">-</span>name <span class="keyword">as</span> <span class="keyword">new</span><span class="operator">-</span>name</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> name <span class="keyword">as</span> instructor_name,course_id</span><br><span class="line"><span class="keyword">from</span> instructor,teches</span><br><span class="line"><span class="keyword">where</span> instructor.ID<span class="operator">=</span>teches.ID;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> T.name,S.course_id</span><br><span class="line"><span class="keyword">from</span> instructor <span class="keyword">as</span> T,teches <span class="keyword">as</span> S</span><br><span class="line"><span class="keyword">where</span> T.ID<span class="operator">=</span>S.ID</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>适用于比较同一关系中元组的情况,T S 被称为表别名 相关变量 元组变量</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> T.name</span><br><span class="line"><span class="keyword">from</span> instructor <span class="keyword">as</span> T,instructor <span class="keyword">as</span> S</span><br><span class="line"><span class="keyword">where</span> T.salary<span class="operator">&gt;</span>S.salary <span class="keyword">and</span> S.dept_name<span class="operator">=</span><span class="string">&#x27;Biology&#x27;</span>;</span><br></pre></td></tr></table></figure><h4 id="字符串运算"><a href="#字符串运算" class="headerlink" title="字符串运算"></a>字符串运算</h4><p>SQL字符串匹配大小写敏感，MySQL和SQL Server大小写不敏感</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">upper</span>(s)</span><br><span class="line"><span class="built_in">lower</span>(s)</span><br><span class="line"><span class="built_in">trim</span>(s)<span class="operator">/</span><span class="operator">/</span>去末尾空格</span><br></pre></td></tr></table></figure><p>%匹配任任任意子串，_匹配一个任意字符</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> dept_name</span><br><span class="line"><span class="keyword">from</span> department</span><br><span class="line"><span class="keyword">where</span> building <span class="keyword">like</span> <span class="string">&#x27;%Watson%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="keyword">escape</span>匹配转义字符</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="keyword">not</span> <span class="keyword">like</span> 搜索不匹配项</span><br><span class="line"><span class="keyword">like</span> <span class="string">&#x27;ad\\cd%&#x27;</span> <span class="keyword">escape</span> <span class="string">&#x27;\&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="语句补充"><a href="#语句补充" class="headerlink" title="语句补充"></a>语句补充</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> instructor.<span class="operator">*</span><span class="operator">/</span><span class="operator">/</span>选中所有属性</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> salary <span class="keyword">desc</span>,name <span class="keyword">asc</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> name</span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">where</span> salary <span class="keyword">between</span> <span class="number">900</span> <span class="keyword">and</span> <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> name, course_id,</span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">where</span> (instructor.ID,dept_name)<span class="operator">=</span>(teches.ID,<span class="string">&#x27;Biology&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="关系运算"><a href="#关系运算" class="headerlink" title="关系运算"></a>关系运算</h3><p>union intersect except默认去重，union all 不去重<br>except在执行差操作前进行去重</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">select</span> course_id</span><br><span class="line"><span class="keyword">from</span> section</span><br><span class="line"><span class="keyword">where</span> semester<span class="operator">=</span><span class="string">&#x27;Fall&#x27;</span><span class="keyword">and</span> <span class="keyword">year</span><span class="operator">=</span><span class="number">2017</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">union</span></span><br><span class="line">(<span class="keyword">select</span> course_id</span><br><span class="line"><span class="keyword">from</span> section</span><br><span class="line"><span class="keyword">where</span> semester<span class="operator">=</span><span class="string">&#x27;Fall&#x27;</span><span class="keyword">and</span> <span class="keyword">year</span><span class="operator">=</span><span class="number">2017</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="空值"><a href="#空值" class="headerlink" title="空值"></a>空值</h3><p>对null的算术运算为null<br>对null的比较运算为unknown</p><ul><li>true and unknown —unknown</li><li>true or unknown —true</li><li>not unknown —unknown</li></ul><p>null 测试空值 not null 非空<br>is unknown   is not unknown</p><p>去重时，属性的两个值为空会判断为相等<br>在where语句中，null&#x3D;null返回unknown</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name</span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">where</span> salary <span class="keyword">is</span> <span class="keyword">null</span></span><br></pre></td></tr></table></figure><h3 id="聚集函数"><a href="#聚集函数" class="headerlink" title="聚集函数"></a>聚集函数</h3><ul><li>avg</li><li>min</li><li>max</li><li>sum</li><li>count</li></ul><p>sum 和 avg输入需要是数字集</p><p>count（*）找到元组数量，不允许使用distinct</p><h4 id="分组聚集"><a href="#分组聚集" class="headerlink" title="分组聚集"></a>分组聚集</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> dept_name,<span class="built_in">avg</span>(salary) <span class="keyword">as</span> avg_salary</span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> dept_name</span><br></pre></td></tr></table></figure><p>任何没有出现在group by子句的属性必须作为聚集的参数属性</p><p>使用”&#x2F;* *&#x2F;“或“–注释”添加注释</p><h4 id="having-子句"><a href="#having-子句" class="headerlink" title="having 子句"></a>having 子句</h4><p>为分组添加限定,任何出现在having中的没有被聚集的属性必须出现在group by子句中</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> dept_name,<span class="built_in">avg</span>(salary) <span class="keyword">as</span> avg_salary</span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> dept_name</span><br><span class="line"><span class="keyword">having</span> <span class="built_in">avg</span>(salary)<span class="operator">&gt;</span><span class="number">4200</span>;</span><br></pre></td></tr></table></figure><h4 id="空值和布尔的聚集"><a href="#空值和布尔的聚集" class="headerlink" title="空值和布尔的聚集"></a>空值和布尔的聚集</h4><p>除count（*）外的聚集忽略空值，空集的count为0,对于空集的聚集运算返回空置</p><p>some every可对bool值进行聚集运算，析取与合取</p><h3 id="嵌套子查询"><a href="#嵌套子查询" class="headerlink" title="嵌套子查询"></a>嵌套子查询</h3><h4 id="集合成员资格"><a href="#集合成员资格" class="headerlink" title="集合成员资格"></a>集合成员资格</h4><p>连接词in测试集合成员资格，not in测试缺失</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">select</span> course_id</span><br><span class="line"><span class="keyword">from</span> section</span><br><span class="line"><span class="keyword">where</span> semester<span class="operator">=</span><span class="string">&#x27;Spring&#x27;</span> <span class="keyword">and</span> <span class="keyword">year</span><span class="operator">=</span><span class="number">2017</span> <span class="keyword">and</span></span><br><span class="line">    course <span class="keyword">in</span>(<span class="keyword">select</span> course_id</span><br><span class="line">              <span class="keyword">from</span> section</span><br><span class="line">              <span class="keyword">where</span> semester<span class="operator">=</span><span class="string">&#x27;Spring&#x27;</span> <span class="keyword">and</span> <span class="keyword">year</span> <span class="operator">=</span><span class="number">2018</span></span><br><span class="line">    ));</span><br><span class="line"></span><br><span class="line">&quot;/* 使用in 枚举集合*/&quot;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> name</span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">where</span> name <span class="keyword">not</span> <span class="keyword">in</span> (<span class="string">&#x27;Mozart&#x27;</span>,<span class="string">&#x27;Einstein&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="集合比较"><a href="#集合比较" class="headerlink" title="集合比较"></a>集合比较</h4><p>支持&lt;some &lt;&#x3D;some &gt;&#x3D;some &#x3D;some &lt;&gt;some<br>支持&lt;all &lt;&#x3D;all &gt;&#x3D;all &#x3D;all &lt;&gt;all </p><p>&#x3D;some 等价于in, &lt;&gt;some不等价于not in<br>&lt;&gt;all 等价于not in, &#x3D;all不等价于in</p><h4 id="空关系测试"><a href="#空关系测试" class="headerlink" title="空关系测试"></a>空关系测试</h4><p>exists,not exists<br>A包含B等价于not exists(B except A)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> course_id</span><br><span class="line"><span class="keyword">from</span> section <span class="keyword">as</span> S</span><br><span class="line"><span class="keyword">where</span> semester<span class="operator">=</span>‘Fall’ <span class="keyword">and</span> <span class="keyword">year</span><span class="operator">=</span><span class="number">2017</span> <span class="keyword">and</span></span><br><span class="line">    <span class="keyword">exists</span>(<span class="keyword">select</span> .<span class="operator">*</span></span><br><span class="line">           <span class="keyword">from</span> section <span class="keyword">as</span> T</span><br><span class="line">           <span class="keyword">where</span> semester<span class="operator">=</span><span class="string">&#x27;Spring&#x27;</span> <span class="keyword">and</span> <span class="keyword">year</span><span class="operator">=</span><span class="number">2018</span> <span class="keyword">and</span> S.course_id<span class="operator">=</span>T.course_id);</span><br></pre></td></tr></table></figure><h4 id="重复组测试"><a href="#重复组测试" class="headerlink" title="重复组测试"></a>重复组测试</h4><p>unique ，not unqiue</p><h4 id="with子句"><a href="#with子句" class="headerlink" title="with子句"></a>with子句</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> dept_total(dept_name,<span class="keyword">value</span>) <span class="keyword">as</span></span><br><span class="line">    (<span class="keyword">select</span> dept_name,<span class="built_in">sum</span>(salary)</span><br><span class="line">     <span class="keyword">from</span> instructor</span><br><span class="line">     <span class="keyword">group</span> <span class="keyword">by</span> dept_name),</span><br><span class="line">dept_total_avg(<span class="keyword">value</span>) <span class="keyword">as</span></span><br><span class="line">    (<span class="keyword">select</span> <span class="built_in">avg</span>(<span class="keyword">value</span>))</span><br><span class="line">     <span class="keyword">from</span> dept_total)</span><br><span class="line"><span class="keyword">select</span> dept_name</span><br><span class="line"><span class="keyword">from</span> dept_total,dept_total_avg</span><br><span class="line"><span class="keyword">where</span> dept_total.value<span class="operator">&gt;</span>dept_total_avg.value;</span><br></pre></td></tr></table></figure><h3 id="数据库更改"><a href="#数据库更改" class="headerlink" title="数据库更改"></a>数据库更改</h3><p>删除只能删除整个元组，不能只删除某些属性上的值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> r</span><br><span class="line"><span class="keyword">where</span> P;</span><br></pre></td></tr></table></figure><p>插入一个元组</p><p>大部分关系数据库有bulk loader工具，向关系插入一个非常大的元组集合，可以从格式化的文本文件读取数据，执行速度快得多</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>属性排列顺序对应</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> course </span><br><span class="line">    <span class="keyword">values</span>(‘CS<span class="number">-437</span>’，‘DataBase Systems’,<span class="string">&#x27;Comp.Sci&#x27;</span>,<span class="number">4</span>);</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>任意顺序</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> course(title,course_id,credits,dept_name)</span><br><span class="line">    <span class="keyword">values</span>(<span class="string">&#x27;DataBase System&#x27;</span>,<span class="string">&#x27;CS-437&#x27;</span>,<span class="number">4</span>,<span class="string">&#x27;Comp.Sci&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> instructor</span><br><span class="line">    <span class="keyword">select</span> ID,name,dept_name,<span class="number">18000</span></span><br><span class="line">    <span class="keyword">from</span> student</span><br><span class="line">    <span class="keyword">where</span> dept_name<span class="operator">=</span><span class="string">&#x27;Music&#x27;</span> <span class="keyword">and</span> tot_cred<span class="operator">&gt;</span><span class="number">144</span>;</span><br></pre></td></tr></table></figure><p>数据库更新</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> instructor</span><br><span class="line"><span class="keyword">set</span> salary<span class="operator">=</span>salary<span class="operator">*</span><span class="number">1.05</span></span><br><span class="line"><span class="keyword">where</span> salary<span class="operator">&lt;</span><span class="number">70000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> instructor</span><br><span class="line"><span class="keyword">set</span> salary<span class="operator">=</span><span class="keyword">case</span></span><br><span class="line">            <span class="keyword">when</span> salary<span class="operator">&lt;=</span><span class="number">100000</span> <span class="keyword">then</span> salary<span class="operator">*</span><span class="number">1.05</span></span><br><span class="line">            <span class="keyword">else</span> salary<span class="operator">*</span><span class="number">1.03</span></span><br><span class="line">           <span class="keyword">end</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>关系模型介绍</title>
      <link href="/2024/06/22/%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B%E4%BB%8B%E7%BB%8D/"/>
      <url>/2024/06/22/%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="关系模型介绍"><a href="#关系模型介绍" class="headerlink" title="关系模型介绍"></a>关系模型介绍</h2><h3 id="关系数据库结构"><a href="#关系数据库结构" class="headerlink" title="关系数据库结构"></a>关系数据库结构</h3><p>关系数据库由表的集合构成，关系指代表，元组指代行，属性指代列，关系实例指代特定行。</p><p>关系的每个属性都存在一个取值集合，称为域，所有属性的域要是原子的，空直表示未知或者不存在</p><h3 id="数据库模式"><a href="#数据库模式" class="headerlink" title="数据库模式"></a>数据库模式</h3><p>关系模式由属性列表和对应的域组成4</p><h3 id="码"><a href="#码" class="headerlink" title="码"></a>码</h3><p>一个元组的所有属性是该元组的唯一标识符，一个关系中的两个元组的属性不能全部相同。</p><p>超码是一个或多个属性的集合，能够唯一标识出一个元组，最小超码成为候选码。</p><p>主码是数据库管理者选中的区分元组的候选码，列在其他属性之前，使用下划线标识，其置极少或不变化。</p><p>一个关系A引用另一个关系B时，关系A中关于B的属性称为外码，A是引用关系，B是被引用关系。被引用属性必须是B的主码。引用完整性约束要求A在指定属性上的取值必然出现在至少一个B的元组的属性取值上</p><h3 id="关系查询语言"><a href="#关系查询语言" class="headerlink" title="关系查询语言"></a>关系查询语言</h3><p>查询语言用来从数据库请求获取信息</p><ul><li>命令式</li><li>函数式</li><li>声明式</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据库系统概述</title>
      <link href="/2024/06/22/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"/>
      <url>/2024/06/22/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="数据库管理系统（DBMS）"><a href="#数据库管理系统（DBMS）" class="headerlink" title="数据库管理系统（DBMS）"></a>数据库管理系统（DBMS）</h2><p>由一个相互关联的数据的集合和一组访问这些数据的程序组成。DBMS主要目标是提供一种可以方便，高效存取数据库信息的途径</p><p>使用数据库的方式：</p><ul><li>联机事务处理，对小部分数据进行更新</li><li>数据分析，审阅数据，得出结论</li></ul><h3 id="文件处理系统的弊端"><a href="#文件处理系统的弊端" class="headerlink" title="文件处理系统的弊端"></a>文件处理系统的弊端</h3><ul><li>数据冗余和不一致</li><li>数据访问困难，不支持一种便捷高效的方式获取所需数据</li><li>数据孤立</li><li>完整性问题，数据的一致性约束</li><li>原子性问题</li><li>并发访问异常</li><li>安全性问题，数据访问权限</li></ul><h3 id="数据视图"><a href="#数据视图" class="headerlink" title="数据视图"></a>数据视图</h3><p>提供给用户的抽象视图</p><p>数据模型</p><ul><li>关系模型（relational model）</li><li>实体-联系模型（entity-relationship model）</li><li>半结构化模型(semi-structured model)</li><li>基于对象的数据模型(object-based model)</li></ul><p>关系数据模型：数据以表的形式呈现</p><p>数据抽象</p><ul><li>物理层，数据存储的底层逻辑，使用索引支持高效检索</li><li>逻辑层，存储什么数据，数据之间的关系</li><li>视图层，简化交互，提供安全性机制</li></ul><p>实例和模式：实例是特定时刻存储在数据库信息的集合，数据库的总体设计称为模式（物理模式，逻辑模式，视图有子模式）</p><h3 id="数据库语言"><a href="#数据库语言" class="headerlink" title="数据库语言"></a>数据库语言</h3><p>数据库定义语言(DLL)定义数据库模式，数据操纵语言（DML）表示数据库查询和更新，SQL包含两种。</p><p>DLL提供</p><ul><li>域约束</li><li>引用完整性</li><li>授权<br>输出存在数据字典中，数据字典包含元数据</li></ul><p>DML：增删改查<br>过程化DML：指定需要的数据和如何获取<br>声明式DML：无需指定</p><h3 id="数据库引擎"><a href="#数据库引擎" class="headerlink" title="数据库引擎"></a>数据库引擎</h3><p>存储管理器，减少主存和磁盘的移动需求</p><p>查询处理器部件，简化数据访问</p><p>事务管理部件，原子性操作</p><p>存储管理器部件：</p><ul><li>权限及完整性管理器：检测完整性和用户权限</li><li>事务管理器：并发事务执行不冲突</li><li>文件管理器：管理磁盘分配</li><li>缓冲区管理器：管理内存写入<br>数据结构：</li><li>数据文件：数据库本身</li><li>数据字典：元数据</li><li>索引</li></ul><p>查询处理器组件：</p><ul><li>DDL解释器，解释DLL存储在数据字典</li><li>DML编译器，翻译DML，查询优化</li><li>查询执行引擎，执行编译生成的低级指令</li></ul><p>事务管理组件：</p><ul><li>恢复管理器</li><li>并发控制管理器</li></ul><h3 id="数据库和应用体系结构"><a href="#数据库和应用体系结构" class="headerlink" title="数据库和应用体系结构"></a>数据库和应用体系结构</h3><p>两层体系结构：用户-应用程序-数据库系统<br>三层体系结构：用户-应用客户-应用服务器-数据库系统</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>原子更新技术</title>
      <link href="/2024/06/10/%E5%8E%9F%E5%AD%90%E6%9B%B4%E6%96%B0%E6%8A%80%E6%9C%AF/"/>
      <url>/2024/06/10/%E5%8E%9F%E5%AD%90%E6%9B%B4%E6%96%B0%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络概述</title>
      <link href="/2024/06/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/"/>
      <url>/2024/06/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是计算机网络"><a href="#什么是计算机网络" class="headerlink" title="什么是计算机网络"></a>什么是计算机网络</h2><p>通信模型：信源-&gt;发送设备-&gt;信道（有噪声源干扰）-&gt;接受设备-&gt;信宿<br>计算机网络就是互联的，自治的计算机集合，由通信链路链接<br>通过交换网络互联主机</p><h3 id="Internet"><a href="#Internet" class="headerlink" title="Internet"></a>Internet</h3><p>全球最大的互联网络<br>互联网络：网络的网络，Internet Service Provider (ISP)</p><p>计算设备集合：主机&#x3D;端系统<br>通信链路：光纤，铜缆，卫星<br>分组交换：路由器，交换机</p><h3 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h3><p>进行网络中数据交换而建立的规则，标准或约定，规定了通信实体交换信息的格式，意义，顺序以及针对受到信息或发生的事件采取的动作<br>协议三要素：</p><ul><li>语法：数据和控制信息的结构</li><li>语义：需要发出什么控制信息，做出何种响应</li><li>时序：事件顺序，速度匹配</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>UsingFileSystem</title>
      <link href="/2024/06/02/UsingFileSystem/"/>
      <url>/2024/06/02/UsingFileSystem/</url>
      
        <content type="html"><![CDATA[<h2 id="使用文件系统"><a href="#使用文件系统" class="headerlink" title="使用文件系统"></a>使用文件系统</h2><h3 id="硬链接与符号文件"><a href="#硬链接与符号文件" class="headerlink" title="硬链接与符号文件"></a>硬链接与符号文件</h3><p>硬链接：inode编号一样，文件名不一样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln test.txt test2.txt</span><br></pre></td></tr></table></figure><p>符号链接：一个假的文件，只保存目标文件的目录,目标文件目录失效，链接也失效（快捷方式）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s test.txt test2.txt</span><br></pre></td></tr></table></figure><h3 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h3><p>应用程序会保存一个数组存储使用到的文件描述符，无论进程有多少，文件只有一份</p><h3 id="文件接口"><a href="#文件接口" class="headerlink" title="文件接口"></a>文件接口</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path,<span class="type">int</span> oflag,...)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">openat</span><span class="params">(<span class="type">int</span> fd,<span class="type">const</span> <span class="type">char</span>* path,<span class="type">int</span> offlag,...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">read</span><span class="params">(<span class="type">int</span> fildes,<span class="type">void</span>* buf,<span class="type">size_t</span> nbyte)</span></span>;</span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">write</span><span class="params">(<span class="type">int</span> fildes,<span class="type">const</span> <span class="type">void</span>*buf,<span class="type">size_t</span> nbytes)</span></span>;</span><br><span class="line"><span class="comment">//调整读写位置</span></span><br><span class="line"><span class="function"><span class="type">off_t</span> <span class="title">lseek</span><span class="params">(<span class="type">int</span> fildes,<span class="type">off_t</span> offset,<span class="type">int</span> whence)</span></span>;</span><br><span class="line"><span class="comment">//获取文件属性</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fstat</span><span class="params">(<span class="type">int</span> flides,<span class="keyword">struct</span> stat *buf)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fstatat</span><span class="params">(<span class="type">int</span> fd,<span class="type">const</span> <span class="type">char</span>* restrict path,<span class="keyword">struct</span> stat* restrict buf,<span class="type">int</span> flag)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lstat</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* restrict path,<span class="keyword">struct</span> stat* restrict buf)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">stat</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* restrict path,<span class="keyword">struct</span> stat*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">close</span><span class="params">(<span class="type">int</span> flides)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="复制文件"><a href="#复制文件" class="headerlink" title="复制文件"></a>复制文件</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 4096<span class="comment">//每次读取4K大小，因为数据块是4k大小存储的</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OUTPUT_MODE 0700</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> in_fd,out_fd,rd_count,wt_count;</span><br><span class="line">    <span class="type">char</span> buffer[BUF_SIZE];</span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">3</span>)<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    in_fd=<span class="built_in">open</span>(argv[<span class="number">1</span>],O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(in_fd&lt;<span class="number">0</span>)<span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">    out_fd=<span class="built_in">creat</span>(argv[<span class="number">2</span>],OUTPUT_MODE);</span><br><span class="line">    <span class="keyword">if</span>(out_fd&lt;<span class="number">0</span>)<span class="built_in">exit</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        rd_count=<span class="built_in">read</span>(in_fd,buffer,BUF_SIZE);</span><br><span class="line">        <span class="keyword">if</span>(rd_count&lt;<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        wt_count=<span class="built_in">write</span>(out_fd,buffer,rd_count);</span><br><span class="line">        <span class="keyword">if</span>(wt_count&lt;=<span class="number">0</span>)<span class="built_in">exit</span>(<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(in_fd);<span class="built_in">close</span>(out_fd);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="页缓存与脏页"><a href="#页缓存与脏页" class="headerlink" title="页缓存与脏页"></a>页缓存与脏页</h3><p>为提高读写效率，操作系统会设置文件缓存，不用每次read&#x2F;write去读写硬盘，数据没有真的写在硬盘，而是写在缓存中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fsync</span><span class="params">(<span class="type">int</span> flides)</span></span>;<span class="comment">//强制将缓存内容写入硬盘，防止断电数据丢失</span></span><br></pre></td></tr></table></figure><h3 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h3><p>mmap可将文件映射到虚拟内存空间中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fd=<span class="built_in">open</span>(<span class="string">&quot;/home/Demo/os_file&quot;</span>,O_RDWR);</span><br><span class="line">addr=<span class="built_in">mmap</span>(<span class="literal">NULL</span>,length,PROT_WRITE,MAP_SHARED,fd,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">memset</span>(addr,<span class="number">0</span>,length);</span><br></pre></td></tr></table></figure><p>实现方式：将虚拟内存中对应的文件改为文件编号，访问mmap返回的虚拟地址时触发缺页中断，缺页中断处理函数通过虚拟地址，找到该文件的inode,从磁盘中将数据写入内存</p><p>优势</p><ul><li>对于随机访问，不要频繁lseek</li><li>减少系统调用次数</li><li>减少数据copy，拷贝文件数据无需经过中间buffer</li><li>访问局部性更好</li><li>可以使用madice为内核提供访问提示，提高性能</li></ul><h3 id="高级功能"><a href="#高级功能" class="headerlink" title="高级功能"></a>高级功能</h3><p>基于内存映射的文件复制</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> input,output,<span class="type">size_t</span> filesize;</span><br><span class="line">    <span class="type">void</span>* source,*target;</span><br><span class="line">    input=<span class="built_in">open</span>(argv[<span class="number">1</span>],O_RDONLY);</span><br><span class="line">    output=<span class="built_in">open</span>(argv[<span class="number">2</span>],O_RDWR|O_CREAT|O_TRUNC,<span class="number">0666</span>);</span><br><span class="line">    filesize=<span class="built_in">lseek</span>(intput,<span class="number">0</span>,SEEK_END);</span><br><span class="line">    <span class="built_in">lseek</span>(output,filesize<span class="number">-1</span>,SEEK_SET);</span><br><span class="line">    <span class="built_in">write</span>(output,<span class="string">&#x27;\0&#x27;</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((source=<span class="built_in">mmap</span>(<span class="number">0</span>,filesize,PROT_READ,MAP_SHARED,input,<span class="number">0</span>))==(<span class="type">void</span>*)<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(stderr,<span class="string">&quot;Error mapping input file:%s\n&quot;</span>,argv[<span class="number">1</span>],<span class="built_in">exit</span>(<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">if</span>((source=<span class="built_in">mmap</span>(<span class="number">0</span>,filesize,PROT_WRITE,MAP_SHARED,output,<span class="number">0</span>))==(<span class="type">void</span>*)<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(stderr,<span class="string">&quot;Error mapping input file:%s\n&quot;</span>,argv[<span class="number">1</span>],<span class="built_in">exit</span>(<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">memcpy</span>(target,source,filesize);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">munmap</span>(source,filesize);<span class="built_in">munmap</span>(target,filesize);</span><br><span class="line">    <span class="built_in">close</span>(input);<span class="built_in">close</span>(output);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于文件系统的文件克隆<br>将文件A的元数据复制一份给文件B，将文件编号修改一下，对数据块进行修改时使用写时拷贝</p><p>快照（snapshot）<br>同样使用写时拷贝<br>基于inode的文件系统：将inode表拷贝一份作为快照保存，标记一用数据区为写时拷贝<br>对于树状结构的文件系统：将树根拷贝一份作为快照保存，树根以下的节点标记为写时拷贝</p><h3 id="虚拟文件系统：Virtual-File-System"><a href="#虚拟文件系统：Virtual-File-System" class="headerlink" title="虚拟文件系统：Virtual File System"></a>虚拟文件系统：Virtual File System</h3><p>每个文件系统都有 超级块(元数据)，根目录，树状结构<br>Linux系统的VFS可以统一挂载一系列接口，具体的文件系统实现这些接口</p><h3 id="用户态文件系统"><a href="#用户态文件系统" class="headerlink" title="用户态文件系统"></a>用户态文件系统</h3><p>优势：</p><ul><li>快速试验文件系统新设计</li><li>大量第三方库可以使用</li><li>方便调试</li><li>无需担心把内核搞崩溃</li><li>实现新功能</li></ul><p>FUSE用户态文件系统框架基本流程</p><ol><li>FUSE文件系统向FUSE驱动注册（挂载）</li><li>应用程序发起文件请求</li><li>根据挂载点，VFS将请求转发给FUSE驱动</li><li>FUSE驱动通过中断，共享内存等方式将请求发给FUSE文件系统</li><li>FUSE文件系统处理请求</li><li>FUSE文件系统通知FUSE驱动请求结果</li><li>FUSE驱动通过VFS返回结果给应用程序</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>FileSystem</title>
      <link href="/2024/05/26/FileSystem/"/>
      <url>/2024/05/26/FileSystem/</url>
      
        <content type="html"><![CDATA[<h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><h3 id="块设备"><a href="#块设备" class="headerlink" title="块设备"></a>块设备</h3><p>传统机械式硬盘：磁盘内有多个轨道，探头一次读取一块数据，单字节读取是不可能的<br>固态硬盘（SSD，Solid State Disk）：阵列式存储，一次读取一行</p><h3 id="基于indoe的文件系统"><a href="#基于indoe的文件系统" class="headerlink" title="基于indoe的文件系统"></a>基于indoe的文件系统</h3><p>indoe是常规文件的数据索引方式<br>48K+6M+1G</p><h3 id="基于表的文件系统"><a href="#基于表的文件系统" class="headerlink" title="基于表的文件系统"></a>基于表的文件系统</h3><h4 id="FAT-文件分配表-File-Allocation-Table"><a href="#FAT-文件分配表-File-Allocation-Table" class="headerlink" title="FAT:文件分配表(File Allocation Table)"></a>FAT:文件分配表(File Allocation Table)</h4><p>Windows系统使用至今<br>数据基本块单位为簇，4K大小</p><p>FAT是簇序号的数组，表示下一个簇，文件由簇的链表形式组织</p><p>链表容易断（硬盘坏道），创建了一模一样的FAT2当备份</p><p>遍历链表，文件越大，读写越慢</p><p>FAT32中，文件大小元数据使用32位整数表示，文件最大为4G</p><h4 id="exFAT-U盘常用格式"><a href="#exFAT-U盘常用格式" class="headerlink" title="exFAT:U盘常用格式"></a>exFAT:U盘常用格式</h4><ul><li>与FAT32不兼容</li><li>使用位图加快空间分配</li><li>Unicode保存长文件名</li><li>目录查找文件使用哈希对比</li><li>允许4G以上文件（文件大小使用8字节）</li><li>使用校验码保证元数据完整性</li></ul><h4 id="NTFS-NEW-Technology-File-System"><a href="#NTFS-NEW-Technology-File-System" class="headerlink" title="NTFS:NEW Technology File System"></a>NTFS:NEW Technology File System</h4><p>现代Windows系统中广泛使用的文件系统<br>核心结构主文件表（Master File Table，MFT）</p><p>前16个保留记录为元数据，记录基本信息<br>$MFT自举：存储自身数据<br>MFT为一个B+树结构</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Deadlock</title>
      <link href="/2024/05/25/Deadlock/"/>
      <url>/2024/05/25/Deadlock/</url>
      
        <content type="html"><![CDATA[<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="死锁产生原因"><a href="#死锁产生原因" class="headerlink" title="死锁产生原因"></a>死锁产生原因</h3><ul><li>互斥访问</li><li>持有并等待</li><li>资源非抢占</li><li>循环等待</li></ul><h3 id="死锁检测与恢复"><a href="#死锁检测与恢复" class="headerlink" title="死锁检测与恢复"></a>死锁检测与恢复</h3><p>恢复方法</p><ul><li>前提条件：可以会滚到之前的某一状态</li><li>直接kill掉所有循环中的线程</li><li>kill一个，看有没有环，有的话继续kill</li></ul><h3 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h3><ul><li>避免互斥访问：通过其他手段(如代理执行，由一个代理线程管理加锁过程，判断加锁操作是否造成环，是则阻塞加锁操作，要在软件设计时规划好架构)</li><li>不允许持有并等待：一次性申请所有资源<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">trylock</span>(A)==SUCC)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">trylock</span>(B)==SUCC)&#123;</span><br><span class="line">            <span class="built_in">unlock</span>(B);</span><br><span class="line">            <span class="built_in">unlock</span>(A);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">unlock</span>(A);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>允许资源抢占：需要考虑恢复(proc_A挤占proc_B资源，让proc_B回滚，proc_A结束后恢复proc_B执行)</li><li>打破循环等待：按照特定顺序获取资源（所有资源进行编号，所有线程递增获取，任意时刻，获取最大资源号的线程可以继续执行，然后释放资源）</li></ul><h3 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h3><p>特定顺序获取资源就可能不会发生死锁，不死锁的调用顺序是安全序列</p><p>银行家算法</p><ul><li>所有线程获取资源需要管理者同意</li><li>管理者预演会不会造成死锁</li><li>如果造成，阻塞线程，下次再给</li></ul><h3 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h3><p>不允许持有且等待形成活锁</p><h3 id="优先级反转"><a href="#优先级反转" class="headerlink" title="优先级反转"></a>优先级反转</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ConditionalVariables</title>
      <link href="/2024/05/25/ConditionalVariables/"/>
      <url>/2024/05/25/ConditionalVariables/</url>
      
        <content type="html"><![CDATA[<h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><p>使用一种特殊机制将线程由运行态转化为阻塞态</p><ul><li>要有操作系统配合</li><li>从阻塞态唤醒为就绪态</li></ul><p>目的：节约CPU资源，留给有需要的线程</p><img src="/2024/05/25/ConditionalVariables/graph.jpeg" class=""><img src="/2024/05/25/ConditionalVariables/signal.jpeg" class=""><p>cond_signal()一定不是自己调用的这是和锁最大的区别</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> empty_slot=<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> filled_slot=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cond</span> empty_cond;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">lock</span> empty_cnt_lock;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cond</span> filled_cond;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">lock</span> filled_cnt_lock;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> new_msg;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        new_msg=<span class="built_in">produce_new</span>();</span><br><span class="line">        <span class="built_in">lock</span>(&amp;empty_cnt_lock);</span><br><span class="line">        <span class="comment">//等待被唤醒</span></span><br><span class="line">        <span class="keyword">while</span>(empty_slot==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">cond_wait</span>(&amp;empty_cond,&amp;empty_cnt_lock);</span><br><span class="line">        &#125;</span><br><span class="line">        empty_slot--;</span><br><span class="line">        <span class="built_in">unlock</span>(&amp;empty_cnt_lock);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">buffer_add_safe</span>(&amp;filled_cnt_lock);</span><br><span class="line">        <span class="built_in">lock</span>(&amp;filled_cnt_lock);</span><br><span class="line">        filled_slot++;</span><br><span class="line">        <span class="built_in">cond_signal</span>(&amp;filled_cond);</span><br><span class="line">        <span class="built_in">unlock</span>(&amp;filled_cnt_lock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> cur_msg;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="built_in">lock</span>(&amp;filled_cnt_lock);</span><br><span class="line">        <span class="keyword">while</span>(&amp;filled_slot==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">cond_wait</span>(&amp;filled_cond,&amp;filled_cnt_lock);</span><br><span class="line">        &#125;</span><br><span class="line">        filled_slot--;</span><br><span class="line">        <span class="built_in">unlock</span>(&amp;filled_cnt_lock);</span><br><span class="line"></span><br><span class="line">        cur_msg=<span class="built_in">buffer_remove_safe</span>();</span><br><span class="line">        <span class="built_in">lock</span>(&amp;empty_cnt_lock);</span><br><span class="line">        empty_slot++;</span><br><span class="line">        <span class="comment">//条件满足，发送唤醒信号</span></span><br><span class="line">        <span class="built_in">cond_signal</span>(&amp;empty_cond);</span><br><span class="line">        <span class="built_in">unlock</span>(&amp;empty_cnt_lock);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">consume_msg</span>(cur_msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">cond</span>&#123;</span><br><span class="line">    Struct thread* wait_list;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cond_wait</span><span class="params">(<span class="keyword">struct</span> cond* cond,<span class="keyword">struct</span> lock*mutex)</span></span>&#123;</span><br><span class="line">    <span class="built_in">list_append</span>(cond-&gt;wait_list,<span class="built_in">thread_self</span>());</span><br><span class="line">    <span class="built_in">atomic_block_unlock</span>(mutex);</span><br><span class="line">    <span class="built_in">lock</span>(mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cond_signal</span><span class="params">(<span class="keyword">struct</span> cond* cond)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">list_empty</span>(cond-&gt;wait_list))&#123;</span><br><span class="line">        <span class="built_in">wakeup</span>(<span class="built_in">list_remove</span>(cond-&gt;wait_list));<span class="comment">//系统调用唤醒线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cond_broadcast</span><span class="params">(<span class="keyword">struct</span> cond* cond)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">list_empty</span>(cond-&gt;wait_list))&#123;</span><br><span class="line">        <span class="built_in">wakeup</span>(<span class="built_in">list_remove</span>(cond-&gt;wait_list));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>互斥锁VS条件变量</p><ol><li><ul><li>互斥锁：保证临界区只有一个线程访问</li><li>条件变量：避免被堵在外面的线程循环等待</li></ul></li><li><ul><li>互斥锁：参数是锁</li><li>条件变量：参数是cond结构体变量</li></ul></li><li><ul><li>互斥锁：两接口在同一线程内操作</li><li>条件变量——两接口在不同线程调用</li></ul></li></ol><h3 id="信号量（semaphore）"><a href="#信号量（semaphore）" class="headerlink" title="信号量（semaphore）"></a>信号量（semaphore）</h3><p>条件变量的缺陷：cond定义和条件声明分离，要简化设计把条件和变量统一</p><p>信号量：根据剩余资源的数量决定线程执行或者等待，面向多个线程访问有限数量的共享资源，互斥锁面向两个线程</p><p>PV原语：P：检验，在代码中使用wait表示   V：自增，代码中用signal表示 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sem</span>&#123;</span><br><span class="line">    <span class="type">int</span> value;<span class="comment">//剩余资源数量</span></span><br><span class="line">    <span class="type">int</span> wakeup;<span class="comment">//应当唤醒的资源数量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">lock</span> sem_lock;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">cond</span> sem_cond;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">sem_t</span> empty_slot</span><br><span class="line"><span class="type">sem_t</span> filled_slot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="keyword">new</span> msg;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        new_msg=<span class="built_in">produce_new</span>();</span><br><span class="line">        <span class="built_in">wait</span>(&amp;empty_slot);</span><br><span class="line">        <span class="built_in">buffer_add_safe</span>(new_msg);</span><br><span class="line">        <span class="built_in">signal</span>(&amp;filled_slot);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consume</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> cur_msg;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="built_in">wait</span>(&amp;filled_slot);</span><br><span class="line">        cur_msg=<span class="built_in">buffer_remove_safe</span>();</span><br><span class="line">        <span class="built_in">signal</span>(&amp;empty_slot);</span><br><span class="line">        <span class="built_in">consume_msg</span>(cur_msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">struct</span> sem*S)</span></span>&#123;</span><br><span class="line">    <span class="built_in">lock</span>(&amp;S-&gt;sem_lock);</span><br><span class="line">    S-&gt;value--;</span><br><span class="line">    <span class="keyword">if</span>(S-&gt;value&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            <span class="built_in">cond_wait</span>(&amp;S-&gt;sem_cond,&amp;S-&gt;sem_lock);</span><br><span class="line">        &#125;<span class="keyword">while</span>(S-&gt;wakeup==<span class="number">0</span>);</span><br><span class="line">        S-&gt;wakeup--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">unlock</span>(&amp;S-&gt;sem_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">signal</span><span class="params">(<span class="keyword">struct</span> sem *S)</span></span>&#123;</span><br><span class="line">    <span class="built_in">lock</span>(&amp;S-&gt;sem_lock);</span><br><span class="line">    S-&gt;value++;</span><br><span class="line">    <span class="keyword">if</span>(S-&gt;value&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">        S-&gt;wakeup++;</span><br><span class="line">        <span class="built_in">cond_signal</span>(&amp;S-&gt;sem_cond);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">unlock</span>(&amp;S-&gt;sem_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>读的人不会对数据造成影响不互斥，通常情况下，读者多于写者</p><p>读写者：区分读者和写者，允许读者之间并行，读者和写者互斥</p><p>挑战：防止数据读到一半被写者覆盖，使用互斥锁，不能有读者看完，有的读者看一半</p><p>读写锁的偏向性：当临界区有读者且有写者等待进入临界区时，根据读者和写者进入的先后顺序有偏向读者和偏向写者</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*偏向读者的读写锁*/</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">rwlock</span>&#123;</span><br><span class="line">    <span class="type">int</span> reader_cnt;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">lock</span> reader_lock;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">lock</span> writer_lock;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lock_reader</span><span class="params">(<span class="keyword">struct</span> rwlock* lock)</span></span>&#123;</span><br><span class="line">    <span class="built_in">lock</span>(&amp;locker-&gt;reader_lock);</span><br><span class="line">    lock-&gt;readedr_cnt++;</span><br><span class="line">    <span class="keyword">if</span>(lock-&gt;reader_cnt==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">lock</span>(&amp;lock-&gt;writer_lock);<span class="comment">//第一个读者加锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">unlock</span>(&amp;lock-&gt;reader_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unlock_reader</span><span class="params">(<span class="keyword">struct</span> rwlock* lock)</span></span>&#123;</span><br><span class="line">    <span class="built_in">lock</span>(&amp;lock-&gt;reader_lock);</span><br><span class="line">    lock-&gt;reader_cnt--；</span><br><span class="line">    <span class="keyword">if</span>(lock-&gt;reader_cnt==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">unlock</span>(&amp;lock-&gt;writer_lock);<span class="comment">//最后离开的读者释放写者锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">unlock</span>(&amp;lock-&gt;reader_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lock_writer</span><span class="params">(<span class="keyword">struct</span> rwlock* lock)</span></span>&#123;</span><br><span class="line">    <span class="built_in">lock</span>(&amp;lock-&gt;writer_lock);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unlock_writer</span><span class="params">(<span class="keyword">struct</span> rwlock* lock)</span></span>&#123;</span><br><span class="line">    <span class="built_in">unlock</span>(&amp;lock-&gt;writer_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*偏向写者的读写锁*/</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">rwlock</span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> reader_cnt;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">bool</span> has_writer;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">lock</span> lock;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">cond</span> reader_cond;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">cond</span> writer_cond;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lock_reader</span><span class="params">(<span class="keyword">struct</span> rwlock* lock)</span></span>&#123;</span><br><span class="line">    <span class="built_in">lock</span>(&amp;rwlock-&gt;lock);</span><br><span class="line">    <span class="keyword">while</span>(&amp;rwlock-&gt;has_writer==TRUE)&#123;</span><br><span class="line">        <span class="built_in">cond_wait</span>(&amp;rwlock-&gt;writer_cond,&amp;rwlock-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line">    rwlock-&gt;reader_cnt++;</span><br><span class="line">    <span class="built_in">unlock</span>(&amp;rwlock-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unlock_reader</span><span class="params">(<span class="keyword">struct</span> rwlock* rwlock)</span></span>&#123;</span><br><span class="line">    <span class="built_in">lock</span>(&amp;rwlock-&gt;lock);</span><br><span class="line">    rwlock-&gt;reader_cnt--;</span><br><span class="line">    <span class="keyword">if</span>(rwclock-&gt;reader_cnt==<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">cond_signal</span>(&amp;rwlock-&gt;reader_cond);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">unlock</span>(&amp;rwlock-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lock_writer</span><span class="params">(<span class="keyword">struct</span> rwlock* rwlock)</span></span>&#123;</span><br><span class="line">    <span class="built_in">lock</span>(&amp;rwlock-&gt;lock);</span><br><span class="line">    <span class="keyword">while</span>(rwlock-&gt;has_writer==TRUE)&#123;</span><br><span class="line">        <span class="built_in">cond_wait</span>(&amp;rwlock-&gt;writer_cond,&amp;rwlock-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line">    rwlock-&gt;has_writer=TRUE;</span><br><span class="line">    <span class="keyword">while</span>(rwlock-&gt;reader_cnt&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">cond_wait</span>(&amp;lock-&gt;reader_cond,&amp;rwlock-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">unlock</span>(&amp;rwlock-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unlock_writer</span><span class="params">(<span class="keyword">struct</span> rwlock* rwlock)</span></span>&#123;</span><br><span class="line">    <span class="built_in">lock</span>(&amp;rwlock-&gt;lock);</span><br><span class="line">    rwlock-&gt;has_writer=FALSE;</span><br><span class="line">    <span class="built_in">cond_broadcast</span>(&amp;rwlock-&gt;writer_cond);</span><br><span class="line">    <span class="built_in">unlock</span>(&amp;rwlock-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Mutex</title>
      <link href="/2024/05/24/Mutex/"/>
      <url>/2024/05/24/Mutex/</url>
      
        <content type="html"><![CDATA[<h2 id="同步问题的背景"><a href="#同步问题的背景" class="headerlink" title="同步问题的背景"></a>同步问题的背景</h2><h3 id="多核场景"><a href="#多核场景" class="headerlink" title="多核场景"></a>多核场景</h3><p>单核性能瓶颈，需要增加核心数量</p><p>多核的挑战：正确性问题，性能可扩展性问题</p><ul><li>正确性问题场景<ol><li>在不同CPU上时数据同步问题</li><li>在同一个CPU上的上下文切换</li></ol></li></ul><h3 id="生产者消费者模型"><a href="#生产者消费者模型" class="headerlink" title="生产者消费者模型"></a>生产者消费者模型</h3><h3 id="临界区问题"><a href="#临界区问题" class="headerlink" title="临界区问题"></a>临界区问题</h3><p>如何确保线程不会将新产生的数据放到同一个缓存区，造成数据覆盖</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    申请进入缓存区</span><br><span class="line">    临界区部分</span><br><span class="line">    标示推出临界区</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决临界区问题的三个要求</p><ul><li>互斥访问：同一时刻，最多只有一个线程进入缓冲区</li><li>空闲让进：没有线程在临界区时，必须选择一个线程进入临界区</li><li>有限等待：线程申请进入临界区时，必须在有限时间内获得许可</li></ul><p>解决临界区问题的算法：关闭硬件中断，在单核下，线程按照时间片调度，关闭中断可确保临界区只有一个程序，在多核下，不能阻塞其他核心</p><h3 id="皮特森算法"><a href="#皮特森算法" class="headerlink" title="皮特森算法"></a>皮特森算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*flag[]对应为TRUE，表示线程申请进入临界区*/</span></span><br><span class="line"><span class="comment">/*turn裁决谁可以进入临界区*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线程0</span></span><br><span class="line"><span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line">    flag[<span class="number">0</span>]=TRUE;</span><br><span class="line">    turn =<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(flag[<span class="number">1</span>]==TRUE&amp;&amp;turn==<span class="number">1</span>)；</span><br><span class="line">    <span class="comment">//...临界区</span></span><br><span class="line">    flag[<span class="number">0</span>]=FALSE;</span><br><span class="line">    <span class="comment">//其他代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程1</span></span><br><span class="line"><span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line">    flag[<span class="number">1</span>]=TRUE;</span><br><span class="line">    turn =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(flag[<span class="number">1</span>]==TRUE&amp;&amp;turn==<span class="number">0</span>)；</span><br><span class="line">    <span class="comment">//...临界区</span></span><br><span class="line">    flag[<span class="number">1</span>]=FALSE;</span><br><span class="line">    <span class="comment">//其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特点：</p><ul><li>适用于两个线程，后来可以拓展为多个线程</li><li>要求线程读取操作严格按照程序顺序执行，现代CPU有乱序执行机制，皮特森算法失效</li></ul><h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><h3 id="原子操作（软硬结合的方法）"><a href="#原子操作（软硬结合的方法）" class="headerlink" title="原子操作（软硬结合的方法）"></a>原子操作（软硬结合的方法）</h3><p>原子操作：不可被打断的一个或一系列操作，由一条汇编语言完成<br>常见原子操作<br>    1. 不可被打断的操作集合<br>    2. 如同执行一条指令<br>    3. 其他CPU核心不会看到中间状态</p><ul><li>Compate-And-Swap CAS<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">CAS</span><span class="params">(<span class="type">int</span> *addr,<span class="type">int</span> expected,<span class="type">int</span> new_value)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp=*addr;</span><br><span class="line">    <span class="keyword">if</span>(*addr==expected)*addr=new_value;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">CAS</span>(lock,<span class="number">0</span>,<span class="number">1</span>)!=<span class="number">0</span>);    <span class="comment">//申请进入临界区</span></span><br><span class="line">    <span class="comment">//...临界区部分</span></span><br><span class="line">    *lock=<span class="number">0</span>；   <span class="comment">//标识退出临界区</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>Fetch-And-Add FAA<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">FAA</span><span class="params">(<span class="type">int</span> *addr,<span class="type">int</span> add_value)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp =*addr;</span><br><span class="line">    *addr =temp+add_value;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>Intel 使用锁总线硬件实现<br>ARM 使用LL&#x2F;SC实现（Load-linked Store-conditional） 使用CPU监视器</p><h3 id="互斥锁抽象"><a href="#互斥锁抽象" class="headerlink" title="互斥锁抽象"></a>互斥锁抽象</h3><ul><li>自选锁（spin lock）<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">lock_init</span><span class="params">(<span class="type">int</span> *lock)</span></span>&#123;</span><br><span class="line">    *lock=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">(<span class="type">int</span>* lock)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">atomic_CAS</span>(lock,<span class="number">0</span>,<span class="number">1</span>)!=<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unlock</span><span class="params">(<span class="type">int</span> *lock)</span></span>&#123;</span><br><span class="line">    *lock=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>可以保证互斥访问与空闲让进</li><li>优点：效率高，响应快</li><li>缺点：不能保证有限等待，批准进入临界区很随意，不保证公平，有些CPU抢不到，while循环太浪费CPU资源</li><li>排号自旋锁（ticket lock）<br>保证竞争者的公平性，先到先得<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*owner 当前的使用者*/</span></span><br><span class="line"><span class="comment">/*next 目前放号的最新值*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lock_init</span><span class="params">(<span class="keyword">struct</span> lock*lock)</span></span>&#123;</span><br><span class="line">    lock-&gt;owner=<span class="number">0</span>;</span><br><span class="line">    lock-&gt;next=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">(<span class="keyword">struct</span> lock *lock)</span></span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> my_ticket=<span class="built_in">atomic_FAA</span>(&amp;lock-&gt;next,<span class="number">1</span>);<span class="comment">//拿到自己的号码</span></span><br><span class="line">    <span class="keyword">while</span>(lock-&gt;owner!=my_ticket);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unlock</span><span class="params">(<span class="keyword">struct</span> lock* lock)</span></span>&#123;</span><br><span class="line">    lock-&gt;owner++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>InterprocessCommunication</title>
      <link href="/2024/05/23/InterprocessCommunication/"/>
      <url>/2024/05/23/InterprocessCommunication/</url>
      
        <content type="html"><![CDATA[<h2 id="进程间通信-IPC"><a href="#进程间通信-IPC" class="headerlink" title="进程间通信(IPC)"></a>进程间通信(IPC)</h2><h3 id="通信基础"><a href="#通信基础" class="headerlink" title="通信基础"></a>通信基础</h3><ul><li><p>独立进程的问题</p><ul><li>大量重复的实现</li><li>低效实现</li><li>没有信息共享</li></ul></li><li><p>协作进程的优点</p><ul><li>模块化</li><li>加速计算</li><li>信息共享</li></ul></li><li><p>进程间通信：发送者—》接受者</p></li></ul><h3 id="共享内存通信"><a href="#共享内存通信" class="headerlink" title="共享内存通信"></a>共享内存通信</h3><p>将两个进程的虚拟内存映射到同一块物理内存上</p><ul><li>挑战：做好同步，发送者不能覆盖未读取数据，接受者不能读取别的数据<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE=10;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;item;</span><br><span class="line"></span><br><span class="line">item buffer[BUFFER_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> in=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> out=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送者实现</span></span><br><span class="line"><span class="keyword">while</span>(new_package)&#123;</span><br><span class="line">    <span class="keyword">while</span>(((in+<span class="number">1</span>)%BUFFER_SIZE)==out);</span><br><span class="line">    buffer[in]=item;</span><br><span class="line">    in=(in+<span class="number">1</span>)%BUFFER_SIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接受者实现</span></span><br><span class="line"><span class="keyword">while</span>(wait_package)&#123;</span><br><span class="line">    <span class="keyword">while</span>(in==out);</span><br><span class="line">    item=buffer[out];</span><br><span class="line">    out=(out+<span class="number">1</span>)%BUFFER_SIZE;</span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>缺陷：轮询导致资源浪费或固定一个检查时间，时延长</li></ul><h3 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h3><p>消息系统：通过中间层（如内核）保证通信时延，仍利用共享内存传递数据</p><ul><li><p>优点：低时延（消息立即转发），不浪费计算资源</p></li><li><p>基本操作：发送消息 接受消息</p></li></ul><p>直接通信</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发送者实现</span></span><br><span class="line"><span class="keyword">while</span>(new_package)&#123;</span><br><span class="line">    <span class="keyword">while</span>(((in+<span class="number">1</span>)%BUFFER_SIZE)==out);</span><br><span class="line">    buffer[in]=item;</span><br><span class="line">    in=(in+<span class="number">1</span>)%BUFFER_SIZE;</span><br><span class="line">    <span class="built_in">Send</span>(xiaoming,<span class="string">&quot;Package&quot;</span>);<span class="comment">//指明接受者</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接受者实现</span></span><br><span class="line"><span class="keyword">while</span>(wait_package)&#123;</span><br><span class="line">    Recv（Expresssman，Msg）；<span class="comment">//接受到消息</span></span><br><span class="line">    <span class="keyword">while</span>(in==out);</span><br><span class="line">    item=buffer[out];</span><br><span class="line">    out=(out+<span class="number">1</span>)%BUFFER_SIZE;</span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>间接通信：消息发送和接受经过一个信箱</p><ul><li>进程间连接的建议和i发生在一个共享信箱</li><li>每对进程可以有多个连接</li><li>连接可以是单向或双向</li></ul><p>操作流程：创建信箱 通过信箱发送和接受消息 销毁信箱</p><p>原语：Send（）  Recv（）</p><p>挑战</p><ul><li>P1发送消息，P2,P3负责接受消息，有谁来接受最新消息</li></ul><p>解决</p><ol><li>让一个连接只能最多被两个进程共享</li><li>同一时间，只允许最多一个进程执行接受操作</li><li>让消息系统任意选择一个闲着的接受者（需要通知发送者谁是接受者）（主流）</li></ol><p>核心问题：发送者是否要阻塞等待消息被确认或者非阻塞发送下一个消息</p><p>同步通信：阻塞的发送和接受，发送者或接受者一直处于阻塞状态，直到消息接受或者发送，有更低时延和易用的编程模型<br>异步通信：发送者接受者不等待操作结果，直接返回，异步通信带宽更高，可以发送更多的消息</p><p>超时机制：尽可能同步通信，超过一定时间后返回，Send(A,message,timeout)</p><p>通信缓冲：通信连接可以选择保留没有处理的消息</p><ul><li>零容量：不缓冲，发送者必须阻塞等待消息接受</li><li>有限容量：超过容量阻塞等待</li><li>无限容量：发送者几乎不等待</li></ul><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>Unix管道是Unix等宏内核中重要的通信机制，一端投递，一端接收，是一种间接消息传递机制，eg:ls|grep fork</p><p>特点</p><ul><li>单向通信，缓冲区满时阻塞</li><li>有且仅有一个输入和输出端口</li><li>数据不带类型，即字节流</li><li>基于Unix文件描述符使用</li></ul><p>优点：实现简单，对于简单场景有效<br>问题：</p><ol><li>缺少消息类型，需要接受者进行解析</li><li>缓冲区大小预先分配且固定</li><li>只能单向通信</li><li>只能最多支持两个进程通信</li></ol><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>带类型的消息传递，以链表形式组织消息 eg:Protobuf(<a href="https://developers.google.cn/protocol-buffers/">https://developers.google.cn/protocol-buffers/</a>)</p><ul><li>任何有权限的进程都可以访问队列，读取，写入</li><li>支持异步通信</li></ul><p>消息的格式：类型+数据（类型使用一个整型表示，由用户自定义）<br>消息队列的组织：FIFO（先进先出原则）<br>允许按照消息类型查询</p><h3 id="管道VS-消息队列"><a href="#管道VS-消息队列" class="headerlink" title="管道VS.消息队列"></a>管道VS.消息队列</h3><p>缓冲区设计</p><ul><li>消息队列：链表组织，动态分配资源，可以设置大上限</li><li>管道：固定缓冲区间，分配过大浪费</li></ul><p>消息格式</p><ul><li>消息队列：带类型的数据</li><li>管道：数据（字节流）</li></ul><p>链接上的进程通信</p><ul><li>消息队列：多个发送者和接受者</li><li>管道：两个端口</li></ul><p>消息管理</p><ul><li>消息队列：FIFO+基于类型查询</li><li>管道：FIFO</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MultiCoreDispatchStrategy</title>
      <link href="/2024/05/23/MultiCoreDispatchStrategy/"/>
      <url>/2024/05/23/MultiCoreDispatchStrategy/</url>
      
        <content type="html"><![CDATA[<h2 id="多核调度策略"><a href="#多核调度策略" class="headerlink" title="多核调度策略"></a>多核调度策略</h2><h3 id="多核下的负载负担"><a href="#多核下的负载负担" class="headerlink" title="多核下的负载负担"></a>多核下的负载负担</h3><p>考虑的问题 ：</p><ul><li>同一个进程的线程具有依赖关系 eg:GCC编译a.out文件</li></ul><p>解决方案 :</p><ul><li><p>协同调度：整体同步并行(Bulk Synchrinius Parallelism,BSP)计算模型，没有依赖关系的并行执行，有依赖关系的等待下一轮运行</p><p>使用场景 ：机器学习，图计算，分布式数据处理平台</p></li><li><p>群组调度（Cang Scheduling）:没有依赖关系的任务分在同一组，以组为单位进行调度</p><p>A B C D 内部没有依赖关系</p></li></ul><p>额外考虑的因素：</p><ul><li>一个进程的不同线程可以在不同CPU上执行，需要尽量让同一个进程的不同线程在同一个逻辑核心运行</li><li>任务在CPU核心间频繁切换对缓存不友好</li></ul><h3 id="缓存友好型调度：两级调度"><a href="#缓存友好型调度：两级调度" class="headerlink" title="缓存友好型调度：两级调度"></a>缓存友好型调度：两级调度</h3><ul><li><p>缺点：CPU负载不均衡</p></li><li><p>优化：</p><ul><li>每个任务特点不同，不能用任务数量代表真实负载</li><li>追踪CPU的负载情况</li><li>将任务从高负载的CPU迁移到低负载CPU</li></ul></li><li><p>负载追踪</p><ul><li>以运行队列为粒度追踪负载：队列长的负载高，迁移那个任务不知道，不够精确</li><li>以调度实体为粒度追踪负载：Per Entity Load Tracking（PELT）：记录每个负载实体对于负载的贡献（有多长时间在运行）    </li></ul></li></ul><h2 id="调度进阶机制"><a href="#调度进阶机制" class="headerlink" title="调度进阶机制"></a>调度进阶机制</h2><h3 id="处理器亲和性（processor-affinity）"><a href="#处理器亲和性（processor-affinity）" class="headerlink" title="处理器亲和性（processor affinity）"></a>处理器亲和性（processor affinity）</h3><p>不同物理内核之间的通信速度不同，操作系统允许程序主动选择使用哪个逻辑核心运行</p><h2 id="现代Linux调度器"><a href="#现代Linux调度器" class="headerlink" title="现代Linux调度器"></a>现代Linux调度器</h2><ul><li>现代处理器的大小核设计（高性能核，省电核）</li><li>CPU的能耗模型<br>  $ W&#x3D;\frac {1}{2}Vf^2 $</li><li>频率降低，处理器速度变慢，性能下降</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/04/30/hello-world/"/>
      <url>/2024/04/30/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
