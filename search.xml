<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>FileSystem</title>
      <link href="/2024/05/26/FileSystem/"/>
      <url>/2024/05/26/FileSystem/</url>
      
        <content type="html"><![CDATA[<h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><h3 id="块设备"><a href="#块设备" class="headerlink" title="块设备"></a>块设备</h3><p>传统机械式硬盘：磁盘内有多个轨道，探头一次读取一块数据，单字节读取是不可能的<br>固态硬盘（SSD，Solid State Disk）：阵列式存储，一次读取一行</p><h3 id="基于indoe的文件系统"><a href="#基于indoe的文件系统" class="headerlink" title="基于indoe的文件系统"></a>基于indoe的文件系统</h3><p>indoe是常规文件的数据索引方式<br>48K+6M+1G</p><h3 id="基于表的文件系统"><a href="#基于表的文件系统" class="headerlink" title="基于表的文件系统"></a>基于表的文件系统</h3><h4 id="FAT-文件分配表-File-Allocation-Table"><a href="#FAT-文件分配表-File-Allocation-Table" class="headerlink" title="FAT:文件分配表(File Allocation Table)"></a>FAT:文件分配表(File Allocation Table)</h4><p>Windows系统使用至今<br>数据基本块单位为簇，4K大小</p><p>FAT是簇序号的数组，表示下一个簇，文件由簇的链表形式组织</p><p>链表容易断（硬盘坏道），创建了一模一样的FAT2当备份</p><p>遍历链表，文件越大，读写越慢</p><p>FAT32中，文件大小元数据使用32位整数表示，文件最大为4G</p><h4 id="exFAT-U盘常用格式"><a href="#exFAT-U盘常用格式" class="headerlink" title="exFAT:U盘常用格式"></a>exFAT:U盘常用格式</h4><ul><li>与FAT32不兼容</li><li>使用位图加快空间分配</li><li>Unicode保存长文件名</li><li>目录查找文件使用哈希对比</li><li>允许4G以上文件（文件大小使用8字节）</li><li>使用校验码保证元数据完整性</li></ul><h4 id="NTFS-NEW-Technology-File-System"><a href="#NTFS-NEW-Technology-File-System" class="headerlink" title="NTFS:NEW Technology File System"></a>NTFS:NEW Technology File System</h4><p>现代Windows系统中广泛使用的文件系统<br>核心结构主文件表（Master File Table，MFT）</p><p>前16个保留记录为元数据，记录基本信息<br>$MFT自举：存储自身数据<br>MFT为一个B+树结构</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Deadlock</title>
      <link href="/2024/05/25/Deadlock/"/>
      <url>/2024/05/25/Deadlock/</url>
      
        <content type="html"><![CDATA[<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="死锁产生原因"><a href="#死锁产生原因" class="headerlink" title="死锁产生原因"></a>死锁产生原因</h3><ul><li>互斥访问</li><li>持有并等待</li><li>资源非抢占</li><li>循环等待</li></ul><h3 id="死锁检测与恢复"><a href="#死锁检测与恢复" class="headerlink" title="死锁检测与恢复"></a>死锁检测与恢复</h3><p>恢复方法</p><ul><li>前提条件：可以会滚到之前的某一状态</li><li>直接kill掉所有循环中的线程</li><li>kill一个，看有没有环，有的话继续kill</li></ul><h3 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h3><ul><li>避免互斥访问：通过其他手段(如代理执行，由一个代理线程管理加锁过程，判断加锁操作是否造成环，是则阻塞加锁操作，要在软件设计时规划好架构)</li><li>不允许持有并等待：一次性申请所有资源<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">trylock</span>(A)==SUCC)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">trylock</span>(B)==SUCC)&#123;</span><br><span class="line">            <span class="built_in">unlock</span>(B);</span><br><span class="line">            <span class="built_in">unlock</span>(A);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">unlock</span>(A);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>允许资源抢占：需要考虑恢复(proc_A挤占proc_B资源，让proc_B回滚，proc_A结束后恢复proc_B执行)</li><li>打破循环等待：按照特定顺序获取资源（所有资源进行编号，所有线程递增获取，任意时刻，获取最大资源号的线程可以继续执行，然后释放资源）</li></ul><h3 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h3><p>特定顺序获取资源就可能不会发生死锁，不死锁的调用顺序是安全序列</p><p>银行家算法</p><ul><li>所有线程获取资源需要管理者同意</li><li>管理者预演会不会造成死锁</li><li>如果造成，阻塞线程，下次再给</li></ul><h3 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h3><p>不允许持有且等待形成活锁</p><h3 id="优先级反转"><a href="#优先级反转" class="headerlink" title="优先级反转"></a>优先级反转</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ConditionalVariables</title>
      <link href="/2024/05/25/ConditionalVariables/"/>
      <url>/2024/05/25/ConditionalVariables/</url>
      
        <content type="html"><![CDATA[<h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><p>使用一种特殊机制将线程由运行态转化为阻塞态</p><ul><li>要有操作系统配合</li><li>从阻塞态唤醒为就绪态</li></ul><p>目的：节约CPU资源，留给有需要的线程</p><img src="/2024/05/25/ConditionalVariables/graph.jpeg" class=""><img src="/2024/05/25/ConditionalVariables/signal.jpeg" class=""><p>cond_signal()一定不是自己调用的这是和锁最大的区别</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> empty_slot=<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> filled_slot=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cond</span> empty_cond;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">lock</span> empty_cnt_lock;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cond</span> filled_cond;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">lock</span> filled_cnt_lock;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> new_msg;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        new_msg=<span class="built_in">produce_new</span>();</span><br><span class="line">        <span class="built_in">lock</span>(&amp;empty_cnt_lock);</span><br><span class="line">        <span class="comment">//等待被唤醒</span></span><br><span class="line">        <span class="keyword">while</span>(empty_slot==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">cond_wait</span>(&amp;empty_cond,&amp;empty_cnt_lock);</span><br><span class="line">        &#125;</span><br><span class="line">        empty_slot--;</span><br><span class="line">        <span class="built_in">unlock</span>(&amp;empty_cnt_lock);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">buffer_add_safe</span>(&amp;filled_cnt_lock);</span><br><span class="line">        <span class="built_in">lock</span>(&amp;filled_cnt_lock);</span><br><span class="line">        filled_slot++;</span><br><span class="line">        <span class="built_in">cond_signal</span>(&amp;filled_cond);</span><br><span class="line">        <span class="built_in">unlock</span>(&amp;filled_cnt_lock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> cur_msg;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="built_in">lock</span>(&amp;filled_cnt_lock);</span><br><span class="line">        <span class="keyword">while</span>(&amp;filled_slot==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">cond_wait</span>(&amp;filled_cond,&amp;filled_cnt_lock);</span><br><span class="line">        &#125;</span><br><span class="line">        filled_slot--;</span><br><span class="line">        <span class="built_in">unlock</span>(&amp;filled_cnt_lock);</span><br><span class="line"></span><br><span class="line">        cur_msg=<span class="built_in">buffer_remove_safe</span>();</span><br><span class="line">        <span class="built_in">lock</span>(&amp;empty_cnt_lock);</span><br><span class="line">        empty_slot++;</span><br><span class="line">        <span class="comment">//条件满足，发送唤醒信号</span></span><br><span class="line">        <span class="built_in">cond_signal</span>(&amp;empty_cond);</span><br><span class="line">        <span class="built_in">unlock</span>(&amp;empty_cnt_lock);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">consume_msg</span>(cur_msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">cond</span>&#123;</span><br><span class="line">    Struct thread* wait_list;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cond_wait</span><span class="params">(<span class="keyword">struct</span> cond* cond,<span class="keyword">struct</span> lock*mutex)</span></span>&#123;</span><br><span class="line">    <span class="built_in">list_append</span>(cond-&gt;wait_list,<span class="built_in">thread_self</span>());</span><br><span class="line">    <span class="built_in">atomic_block_unlock</span>(mutex);</span><br><span class="line">    <span class="built_in">lock</span>(mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cond_signal</span><span class="params">(<span class="keyword">struct</span> cond* cond)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">list_empty</span>(cond-&gt;wait_list))&#123;</span><br><span class="line">        <span class="built_in">wakeup</span>(<span class="built_in">list_remove</span>(cond-&gt;wait_list));<span class="comment">//系统调用唤醒线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cond_broadcast</span><span class="params">(<span class="keyword">struct</span> cond* cond)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">list_empty</span>(cond-&gt;wait_list))&#123;</span><br><span class="line">        <span class="built_in">wakeup</span>(<span class="built_in">list_remove</span>(cond-&gt;wait_list));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>互斥锁VS条件变量</p><ol><li><ul><li>互斥锁：保证临界区只有一个线程访问</li><li>条件变量：避免被堵在外面的线程循环等待</li></ul></li><li><ul><li>互斥锁：参数是锁</li><li>条件变量：参数是cond结构体变量</li></ul></li><li><ul><li>互斥锁：两接口在同一线程内操作</li><li>条件变量——两接口在不同线程调用</li></ul></li></ol><h3 id="信号量（semaphore）"><a href="#信号量（semaphore）" class="headerlink" title="信号量（semaphore）"></a>信号量（semaphore）</h3><p>条件变量的缺陷：cond定义和条件声明分离，要简化设计把条件和变量统一</p><p>信号量：根据剩余资源的数量决定线程执行或者等待，面向多个线程访问有限数量的共享资源，互斥锁面向两个线程</p><p>PV原语：P：检验，在代码中使用wait表示   V：自增，代码中用signal表示 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sem</span>&#123;</span><br><span class="line">    <span class="type">int</span> value;<span class="comment">//剩余资源数量</span></span><br><span class="line">    <span class="type">int</span> wakeup;<span class="comment">//应当唤醒的资源数量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">lock</span> sem_lock;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">cond</span> sem_cond;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">sem_t</span> empty_slot</span><br><span class="line"><span class="type">sem_t</span> filled_slot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="keyword">new</span> msg;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        new_msg=<span class="built_in">produce_new</span>();</span><br><span class="line">        <span class="built_in">wait</span>(&amp;empty_slot);</span><br><span class="line">        <span class="built_in">buffer_add_safe</span>(new_msg);</span><br><span class="line">        <span class="built_in">signal</span>(&amp;filled_slot);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consume</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> cur_msg;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="built_in">wait</span>(&amp;filled_slot);</span><br><span class="line">        cur_msg=<span class="built_in">buffer_remove_safe</span>();</span><br><span class="line">        <span class="built_in">signal</span>(&amp;empty_slot);</span><br><span class="line">        <span class="built_in">consume_msg</span>(cur_msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">struct</span> sem*S)</span></span>&#123;</span><br><span class="line">    <span class="built_in">lock</span>(&amp;S-&gt;sem_lock);</span><br><span class="line">    S-&gt;value--;</span><br><span class="line">    <span class="keyword">if</span>(S-&gt;value&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            <span class="built_in">cond_wait</span>(&amp;S-&gt;sem_cond,&amp;S-&gt;sem_lock);</span><br><span class="line">        &#125;<span class="keyword">while</span>(S-&gt;wakeup==<span class="number">0</span>);</span><br><span class="line">        S-&gt;wakeup--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">unlock</span>(&amp;S-&gt;sem_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">signal</span><span class="params">(<span class="keyword">struct</span> sem *S)</span></span>&#123;</span><br><span class="line">    <span class="built_in">lock</span>(&amp;S-&gt;sem_lock);</span><br><span class="line">    S-&gt;value++;</span><br><span class="line">    <span class="keyword">if</span>(S-&gt;value&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">        S-&gt;wakeup++;</span><br><span class="line">        <span class="built_in">cond_signal</span>(&amp;S-&gt;sem_cond);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">unlock</span>(&amp;S-&gt;sem_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>读的人不会对数据造成影响不互斥，通常情况下，读者多于写者</p><p>读写者：区分读者和写者，允许读者之间并行，读者和写者互斥</p><p>挑战：防止数据读到一半被写者覆盖，使用互斥锁，不能有读者看完，有的读者看一半</p><p>读写锁的偏向性：当临界区有读者且有写者等待进入临界区时，根据读者和写者进入的先后顺序有偏向读者和偏向写者</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*偏向读者的读写锁*/</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">rwlock</span>&#123;</span><br><span class="line">    <span class="type">int</span> reader_cnt;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">lock</span> reader_lock;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">lock</span> writer_lock;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lock_reader</span><span class="params">(<span class="keyword">struct</span> rwlock* lock)</span></span>&#123;</span><br><span class="line">    <span class="built_in">lock</span>(&amp;locker-&gt;reader_lock);</span><br><span class="line">    lock-&gt;readedr_cnt++;</span><br><span class="line">    <span class="keyword">if</span>(lock-&gt;reader_cnt==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">lock</span>(&amp;lock-&gt;writer_lock);<span class="comment">//第一个读者加锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">unlock</span>(&amp;lock-&gt;reader_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unlock_reader</span><span class="params">(<span class="keyword">struct</span> rwlock* lock)</span></span>&#123;</span><br><span class="line">    <span class="built_in">lock</span>(&amp;lock-&gt;reader_lock);</span><br><span class="line">    lock-&gt;reader_cnt--；</span><br><span class="line">    <span class="keyword">if</span>(lock-&gt;reader_cnt==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">unlock</span>(&amp;lock-&gt;writer_lock);<span class="comment">//最后离开的读者释放写者锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">unlock</span>(&amp;lock-&gt;reader_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lock_writer</span><span class="params">(<span class="keyword">struct</span> rwlock* lock)</span></span>&#123;</span><br><span class="line">    <span class="built_in">lock</span>(&amp;lock-&gt;writer_lock);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unlock_writer</span><span class="params">(<span class="keyword">struct</span> rwlock* lock)</span></span>&#123;</span><br><span class="line">    <span class="built_in">unlock</span>(&amp;lock-&gt;writer_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*偏向写者的读写锁*/</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">rwlock</span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> reader_cnt;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">bool</span> has_writer;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">lock</span> lock;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">cond</span> reader_cond;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">cond</span> writer_cond;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lock_reader</span><span class="params">(<span class="keyword">struct</span> rwlock* lock)</span></span>&#123;</span><br><span class="line">    <span class="built_in">lock</span>(&amp;rwlock-&gt;lock);</span><br><span class="line">    <span class="keyword">while</span>(&amp;rwlock-&gt;has_writer==TRUE)&#123;</span><br><span class="line">        <span class="built_in">cond_wait</span>(&amp;rwlock-&gt;writer_cond,&amp;rwlock-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line">    rwlock-&gt;reader_cnt++;</span><br><span class="line">    <span class="built_in">unlock</span>(&amp;rwlock-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unlock_reader</span><span class="params">(<span class="keyword">struct</span> rwlock* rwlock)</span></span>&#123;</span><br><span class="line">    <span class="built_in">lock</span>(&amp;rwlock-&gt;lock);</span><br><span class="line">    rwlock-&gt;reader_cnt--;</span><br><span class="line">    <span class="keyword">if</span>(rwclock-&gt;reader_cnt==<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">cond_signal</span>(&amp;rwlock-&gt;reader_cond);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">unlock</span>(&amp;rwlock-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lock_writer</span><span class="params">(<span class="keyword">struct</span> rwlock* rwlock)</span></span>&#123;</span><br><span class="line">    <span class="built_in">lock</span>(&amp;rwlock-&gt;lock);</span><br><span class="line">    <span class="keyword">while</span>(rwlock-&gt;has_writer==TRUE)&#123;</span><br><span class="line">        <span class="built_in">cond_wait</span>(&amp;rwlock-&gt;writer_cond,&amp;rwlock-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line">    rwlock-&gt;has_writer=TRUE;</span><br><span class="line">    <span class="keyword">while</span>(rwlock-&gt;reader_cnt&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">cond_wait</span>(&amp;lock-&gt;reader_cond,&amp;rwlock-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">unlock</span>(&amp;rwlock-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unlock_writer</span><span class="params">(<span class="keyword">struct</span> rwlock* rwlock)</span></span>&#123;</span><br><span class="line">    <span class="built_in">lock</span>(&amp;rwlock-&gt;lock);</span><br><span class="line">    rwlock-&gt;has_writer=FALSE;</span><br><span class="line">    <span class="built_in">cond_broadcast</span>(&amp;rwlock-&gt;writer_cond);</span><br><span class="line">    <span class="built_in">unlock</span>(&amp;rwlock-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Mutex</title>
      <link href="/2024/05/24/Mutex/"/>
      <url>/2024/05/24/Mutex/</url>
      
        <content type="html"><![CDATA[<h2 id="同步问题的背景"><a href="#同步问题的背景" class="headerlink" title="同步问题的背景"></a>同步问题的背景</h2><h3 id="多核场景"><a href="#多核场景" class="headerlink" title="多核场景"></a>多核场景</h3><p>单核性能瓶颈，需要增加核心数量</p><p>多核的挑战：正确性问题，性能可扩展性问题</p><ul><li>正确性问题场景<ol><li>在不同CPU上时数据同步问题</li><li>在同一个CPU上的上下文切换</li></ol></li></ul><h3 id="生产者消费者模型"><a href="#生产者消费者模型" class="headerlink" title="生产者消费者模型"></a>生产者消费者模型</h3><h3 id="临界区问题"><a href="#临界区问题" class="headerlink" title="临界区问题"></a>临界区问题</h3><p>如何确保线程不会将新产生的数据放到同一个缓存区，造成数据覆盖</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    申请进入缓存区</span><br><span class="line">    临界区部分</span><br><span class="line">    标示推出临界区</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决临界区问题的三个要求</p><ul><li>互斥访问：同一时刻，最多只有一个线程进入缓冲区</li><li>空闲让进：没有线程在临界区时，必须选择一个线程进入临界区</li><li>有限等待：线程申请进入临界区时，必须在有限时间内获得许可</li></ul><p>解决临界区问题的算法：关闭硬件中断，在单核下，线程按照时间片调度，关闭中断可确保临界区只有一个程序，在多核下，不能阻塞其他核心</p><h3 id="皮特森算法"><a href="#皮特森算法" class="headerlink" title="皮特森算法"></a>皮特森算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*flag[]对应为TRUE，表示线程申请进入临界区*/</span></span><br><span class="line"><span class="comment">/*turn裁决谁可以进入临界区*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线程0</span></span><br><span class="line"><span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line">    flag[<span class="number">0</span>]=TRUE;</span><br><span class="line">    turn =<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(flag[<span class="number">1</span>]==TRUE&amp;&amp;turn==<span class="number">1</span>)；</span><br><span class="line">    <span class="comment">//...临界区</span></span><br><span class="line">    flag[<span class="number">0</span>]=FALSE;</span><br><span class="line">    <span class="comment">//其他代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程1</span></span><br><span class="line"><span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line">    flag[<span class="number">1</span>]=TRUE;</span><br><span class="line">    turn =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(flag[<span class="number">1</span>]==TRUE&amp;&amp;turn==<span class="number">0</span>)；</span><br><span class="line">    <span class="comment">//...临界区</span></span><br><span class="line">    flag[<span class="number">1</span>]=FALSE;</span><br><span class="line">    <span class="comment">//其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特点：</p><ul><li>适用于两个线程，后来可以拓展为多个线程</li><li>要求线程读取操作严格按照程序顺序执行，现代CPU有乱序执行机制，皮特森算法失效</li></ul><h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><h3 id="原子操作（软硬结合的方法）"><a href="#原子操作（软硬结合的方法）" class="headerlink" title="原子操作（软硬结合的方法）"></a>原子操作（软硬结合的方法）</h3><p>原子操作：不可被打断的一个或一系列操作，由一条汇编语言完成<br>常见原子操作<br>    1. 不可被打断的操作集合<br>    2. 如同执行一条指令<br>    3. 其他CPU核心不会看到中间状态</p><ul><li>Compate-And-Swap CAS<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">CAS</span><span class="params">(<span class="type">int</span> *addr,<span class="type">int</span> expected,<span class="type">int</span> new_value)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp=*addr;</span><br><span class="line">    <span class="keyword">if</span>(*addr==expected)*addr=new_value;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">CAS</span>(lock,<span class="number">0</span>,<span class="number">1</span>)!=<span class="number">0</span>);    <span class="comment">//申请进入临界区</span></span><br><span class="line">    <span class="comment">//...临界区部分</span></span><br><span class="line">    *lock=<span class="number">0</span>；   <span class="comment">//标识退出临界区</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>Fetch-And-Add FAA<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">FAA</span><span class="params">(<span class="type">int</span> *addr,<span class="type">int</span> add_value)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp =*addr;</span><br><span class="line">    *addr =temp+add_value;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>Intel 使用锁总线硬件实现<br>ARM 使用LL&#x2F;SC实现（Load-linked Store-conditional） 使用CPU监视器</p><h3 id="互斥锁抽象"><a href="#互斥锁抽象" class="headerlink" title="互斥锁抽象"></a>互斥锁抽象</h3><ul><li>自选锁（spin lock）<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">lock_init</span><span class="params">(<span class="type">int</span> *lock)</span></span>&#123;</span><br><span class="line">    *lock=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">(<span class="type">int</span>* lock)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">atomic_CAS</span>(lock,<span class="number">0</span>,<span class="number">1</span>)!=<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unlock</span><span class="params">(<span class="type">int</span> *lock)</span></span>&#123;</span><br><span class="line">    *lock=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>可以保证互斥访问与空闲让进</li><li>优点：效率高，响应快</li><li>缺点：不能保证有限等待，批准进入临界区很随意，不保证公平，有些CPU抢不到，while循环太浪费CPU资源</li><li>排号自旋锁（ticket lock）<br>保证竞争者的公平性，先到先得<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*owner 当前的使用者*/</span></span><br><span class="line"><span class="comment">/*next 目前放号的最新值*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lock_init</span><span class="params">(<span class="keyword">struct</span> lock*lock)</span></span>&#123;</span><br><span class="line">    lock-&gt;owner=<span class="number">0</span>;</span><br><span class="line">    lock-&gt;next=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">(<span class="keyword">struct</span> lock *lock)</span></span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> my_ticket=<span class="built_in">atomic_FAA</span>(&amp;lock-&gt;next,<span class="number">1</span>);<span class="comment">//拿到自己的号码</span></span><br><span class="line">    <span class="keyword">while</span>(lock-&gt;owner!=my_ticket);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unlock</span><span class="params">(<span class="keyword">struct</span> lock* lock)</span></span>&#123;</span><br><span class="line">    lock-&gt;owner++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>InterprocessCommunication</title>
      <link href="/2024/05/23/InterprocessCommunication/"/>
      <url>/2024/05/23/InterprocessCommunication/</url>
      
        <content type="html"><![CDATA[<h2 id="进程间通信-IPC"><a href="#进程间通信-IPC" class="headerlink" title="进程间通信(IPC)"></a>进程间通信(IPC)</h2><h3 id="通信基础"><a href="#通信基础" class="headerlink" title="通信基础"></a>通信基础</h3><ul><li><p>独立进程的问题</p><ul><li>大量重复的实现</li><li>低效实现</li><li>没有信息共享</li></ul></li><li><p>协作进程的优点</p><ul><li>模块化</li><li>加速计算</li><li>信息共享</li></ul></li><li><p>进程间通信：发送者—》接受者</p></li></ul><h3 id="共享内存通信"><a href="#共享内存通信" class="headerlink" title="共享内存通信"></a>共享内存通信</h3><p>将两个进程的虚拟内存映射到同一块物理内存上</p><ul><li>挑战：做好同步，发送者不能覆盖未读取数据，接受者不能读取别的数据<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE=10;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;item;</span><br><span class="line"></span><br><span class="line">item buffer[BUFFER_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> in=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> out=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送者实现</span></span><br><span class="line"><span class="keyword">while</span>(new_package)&#123;</span><br><span class="line">    <span class="keyword">while</span>(((in+<span class="number">1</span>)%BUFFER_SIZE)==out);</span><br><span class="line">    buffer[in]=item;</span><br><span class="line">    in=(in+<span class="number">1</span>)%BUFFER_SIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接受者实现</span></span><br><span class="line"><span class="keyword">while</span>(wait_package)&#123;</span><br><span class="line">    <span class="keyword">while</span>(in==out);</span><br><span class="line">    item=buffer[out];</span><br><span class="line">    out=(out+<span class="number">1</span>)%BUFFER_SIZE;</span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>缺陷：轮询导致资源浪费或固定一个检查时间，时延长</li></ul><h3 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h3><p>消息系统：通过中间层（如内核）保证通信时延，仍利用共享内存传递数据</p><ul><li><p>优点：低时延（消息立即转发），不浪费计算资源</p></li><li><p>基本操作：发送消息 接受消息</p></li></ul><p>直接通信</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发送者实现</span></span><br><span class="line"><span class="keyword">while</span>(new_package)&#123;</span><br><span class="line">    <span class="keyword">while</span>(((in+<span class="number">1</span>)%BUFFER_SIZE)==out);</span><br><span class="line">    buffer[in]=item;</span><br><span class="line">    in=(in+<span class="number">1</span>)%BUFFER_SIZE;</span><br><span class="line">    <span class="built_in">Send</span>(xiaoming,<span class="string">&quot;Package&quot;</span>);<span class="comment">//指明接受者</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接受者实现</span></span><br><span class="line"><span class="keyword">while</span>(wait_package)&#123;</span><br><span class="line">    Recv（Expresssman，Msg）；<span class="comment">//接受到消息</span></span><br><span class="line">    <span class="keyword">while</span>(in==out);</span><br><span class="line">    item=buffer[out];</span><br><span class="line">    out=(out+<span class="number">1</span>)%BUFFER_SIZE;</span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>间接通信：消息发送和接受经过一个信箱</p><ul><li>进程间连接的建议和i发生在一个共享信箱</li><li>每对进程可以有多个连接</li><li>连接可以是单向或双向</li></ul><p>操作流程：创建信箱 通过信箱发送和接受消息 销毁信箱</p><p>原语：Send（）  Recv（）</p><p>挑战</p><ul><li>P1发送消息，P2,P3负责接受消息，有谁来接受最新消息</li></ul><p>解决</p><ol><li>让一个连接只能最多被两个进程共享</li><li>同一时间，只允许最多一个进程执行接受操作</li><li>让消息系统任意选择一个闲着的接受者（需要通知发送者谁是接受者）（主流）</li></ol><p>核心问题：发送者是否要阻塞等待消息被确认或者非阻塞发送下一个消息</p><p>同步通信：阻塞的发送和接受，发送者或接受者一直处于阻塞状态，直到消息接受或者发送，有更低时延和易用的编程模型<br>异步通信：发送者接受者不等待操作结果，直接返回，异步通信带宽更高，可以发送更多的消息</p><p>超时机制：尽可能同步通信，超过一定时间后返回，Send(A,message,timeout)</p><p>通信缓冲：通信连接可以选择保留没有处理的消息</p><ul><li>零容量：不缓冲，发送者必须阻塞等待消息接受</li><li>有限容量：超过容量阻塞等待</li><li>无限容量：发送者几乎不等待</li></ul><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>Unix管道是Unix等宏内核中重要的通信机制，一端投递，一端接收，是一种间接消息传递机制，eg:ls|grep fork</p><p>特点</p><ul><li>单向通信，缓冲区满时阻塞</li><li>有且仅有一个输入和输出端口</li><li>数据不带类型，即字节流</li><li>基于Unix文件描述符使用</li></ul><p>优点：实现简单，对于简单场景有效<br>问题：</p><ol><li>缺少消息类型，需要接受者进行解析</li><li>缓冲区大小预先分配且固定</li><li>只能单向通信</li><li>只能最多支持两个进程通信</li></ol><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>带类型的消息传递，以链表形式组织消息 eg:Protobuf(<a href="https://developers.google.cn/protocol-buffers/">https://developers.google.cn/protocol-buffers/</a>)</p><ul><li>任何有权限的进程都可以访问队列，读取，写入</li><li>支持异步通信</li></ul><p>消息的格式：类型+数据（类型使用一个整型表示，由用户自定义）<br>消息队列的组织：FIFO（先进先出原则）<br>允许按照消息类型查询</p><h3 id="管道VS-消息队列"><a href="#管道VS-消息队列" class="headerlink" title="管道VS.消息队列"></a>管道VS.消息队列</h3><p>缓冲区设计</p><ul><li>消息队列：链表组织，动态分配资源，可以设置大上限</li><li>管道：固定缓冲区间，分配过大浪费</li></ul><p>消息格式</p><ul><li>消息队列：带类型的数据</li><li>管道：数据（字节流）</li></ul><p>链接上的进程通信</p><ul><li>消息队列：多个发送者和接受者</li><li>管道：两个端口</li></ul><p>消息管理</p><ul><li>消息队列：FIFO+基于类型查询</li><li>管道：FIFO</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MultiCoreDispatchStrategy</title>
      <link href="/2024/05/23/MultiCoreDispatchStrategy/"/>
      <url>/2024/05/23/MultiCoreDispatchStrategy/</url>
      
        <content type="html"><![CDATA[<h2 id="多核调度策略"><a href="#多核调度策略" class="headerlink" title="多核调度策略"></a>多核调度策略</h2><h3 id="多核下的负载负担"><a href="#多核下的负载负担" class="headerlink" title="多核下的负载负担"></a>多核下的负载负担</h3><p>考虑的问题 ：</p><ul><li>同一个进程的线程具有依赖关系 eg:GCC编译a.out文件</li></ul><p>解决方案 :</p><ul><li><p>协同调度：整体同步并行(Bulk Synchrinius Parallelism,BSP)计算模型，没有依赖关系的并行执行，有依赖关系的等待下一轮运行</p><p>使用场景 ：机器学习，图计算，分布式数据处理平台</p></li><li><p>群组调度（Cang Scheduling）:没有依赖关系的任务分在同一组，以组为单位进行调度</p><p>A B C D 内部没有依赖关系</p></li></ul><p>额外考虑的因素：</p><ul><li>一个进程的不同线程可以在不同CPU上执行，需要尽量让同一个进程的不同线程在同一个逻辑核心运行</li><li>任务在CPU核心间频繁切换对缓存不友好</li></ul><h3 id="缓存友好型调度：两级调度"><a href="#缓存友好型调度：两级调度" class="headerlink" title="缓存友好型调度：两级调度"></a>缓存友好型调度：两级调度</h3><ul><li><p>缺点：CPU负载不均衡</p></li><li><p>优化：</p><ul><li>每个任务特点不同，不能用任务数量代表真实负载</li><li>追踪CPU的负载情况</li><li>将任务从高负载的CPU迁移到低负载CPU</li></ul></li><li><p>负载追踪</p><ul><li>以运行队列为粒度追踪负载：队列长的负载高，迁移那个任务不知道，不够精确</li><li>以调度实体为粒度追踪负载：Per Entity Load Tracking（PELT）：记录每个负载实体对于负载的贡献（有多长时间在运行）    </li></ul></li></ul><h2 id="调度进阶机制"><a href="#调度进阶机制" class="headerlink" title="调度进阶机制"></a>调度进阶机制</h2><h3 id="处理器亲和性（processor-affinity）"><a href="#处理器亲和性（processor-affinity）" class="headerlink" title="处理器亲和性（processor affinity）"></a>处理器亲和性（processor affinity）</h3><p>不同物理内核之间的通信速度不同，操作系统允许程序主动选择使用哪个逻辑核心运行</p><h2 id="现代Linux调度器"><a href="#现代Linux调度器" class="headerlink" title="现代Linux调度器"></a>现代Linux调度器</h2><ul><li>现代处理器的大小核设计（高性能核，省电核）</li><li>CPU的能耗模型<br>  $ W&#x3D;\frac {1}{2}Vf^2 $</li><li>频率降低，处理器速度变慢，性能下降</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/04/30/hello-world/"/>
      <url>/2024/04/30/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
