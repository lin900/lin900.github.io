<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>InterprocessCommunication</title>
      <link href="/2024/05/23/InterprocessCommunication/"/>
      <url>/2024/05/23/InterprocessCommunication/</url>
      
        <content type="html"><![CDATA[<h2 id="进程间通信-IPC"><a href="#进程间通信-IPC" class="headerlink" title="进程间通信(IPC)"></a>进程间通信(IPC)</h2><h3 id="通信基础"><a href="#通信基础" class="headerlink" title="通信基础"></a>通信基础</h3><ul><li><p>独立进程的问题</p><ul><li>大量重复的实现</li><li>低效实现</li><li>没有信息共享</li></ul></li><li><p>协作进程的优点</p><ul><li>模块化</li><li>加速计算</li><li>信息共享</li></ul></li><li><p>进程间通信：发送者—》接受者</p></li></ul><h3 id="共享内存通信"><a href="#共享内存通信" class="headerlink" title="共享内存通信"></a>共享内存通信</h3><p>将两个进程的虚拟内存映射到同一块物理内存上</p><ul><li>挑战：做好同步，发送者不能覆盖未读取数据，接受者不能读取别的数据<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE=10;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;item;</span><br><span class="line"></span><br><span class="line">item buffer[BUFFER_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> in=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> out=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送者实现</span></span><br><span class="line"><span class="keyword">while</span>(new_package)&#123;</span><br><span class="line">    <span class="keyword">while</span>(((in+<span class="number">1</span>)%BUFFER_SIZE)==out);</span><br><span class="line">    buffer[in]=item;</span><br><span class="line">    in=(in+<span class="number">1</span>)%BUFFER_SIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接受者实现</span></span><br><span class="line"><span class="keyword">while</span>(wait_package)&#123;</span><br><span class="line">    <span class="keyword">while</span>(in==out);</span><br><span class="line">    item=buffer[out];</span><br><span class="line">    out=(out+<span class="number">1</span>)%BUFFER_SIZE;</span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>缺陷：轮询导致资源浪费或固定一个检查时间，时延长</li></ul><h3 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h3><p>消息系统：通过中间层（如内核）保证通信时延，仍利用共享内存传递数据</p><ul><li><p>优点：低时延（消息立即转发），不浪费计算资源</p></li><li><p>基本操作：发送消息 接受消息</p></li></ul><p>直接通信</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发送者实现</span></span><br><span class="line"><span class="keyword">while</span>(new_package)&#123;</span><br><span class="line">    <span class="keyword">while</span>(((in+<span class="number">1</span>)%BUFFER_SIZE)==out);</span><br><span class="line">    buffer[in]=item;</span><br><span class="line">    in=(in+<span class="number">1</span>)%BUFFER_SIZE;</span><br><span class="line">    <span class="built_in">Send</span>(xiaoming,<span class="string">&quot;Package&quot;</span>);<span class="comment">//指明接受者</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接受者实现</span></span><br><span class="line"><span class="keyword">while</span>(wait_package)&#123;</span><br><span class="line">    Recv（Expresssman，Msg）；<span class="comment">//接受到消息</span></span><br><span class="line">    <span class="keyword">while</span>(in==out);</span><br><span class="line">    item=buffer[out];</span><br><span class="line">    out=(out+<span class="number">1</span>)%BUFFER_SIZE;</span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>间接通信：消息发送和接受经过一个信箱</p><ul><li>进程间连接的建议和i发生在一个共享信箱</li><li>每对进程可以有多个连接</li><li>连接可以是单向或双向</li></ul><p>操作流程：创建信箱 通过信箱发送和接受消息 销毁信箱</p><p>原语：Send（）  Recv（）</p><p>挑战</p><ul><li>P1发送消息，P2,P3负责接受消息，有谁来接受最新消息</li></ul><p>解决</p><ol><li>让一个连接只能最多被两个进程共享</li><li>同一时间，只允许最多一个进程执行接受操作</li><li>让消息系统任意选择一个闲着的接受者（需要通知发送者谁是接受者）（主流）</li></ol><p>核心问题：发送者是否要阻塞等待消息被确认或者非阻塞发送下一个消息</p><p>同步通信：阻塞的发送和接受，发送者或接受者一直处于阻塞状态，直到消息接受或者发送，有更低时延和易用的编程模型<br>异步通信：发送者接受者不等待操作结果，直接返回，异步通信带宽更高，可以发送更多的消息</p><p>超时机制：尽可能同步通信，超过一定时间后返回，Send(A,message,timeout)</p><p>通信缓冲：通信连接可以选择保留没有处理的消息</p><ul><li>零容量：不缓冲，发送者必须阻塞等待消息接受</li><li>有限容量：超过容量阻塞等待</li><li>无限容量：发送者几乎不等待</li></ul><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>Unix管道是Unix等宏内核中重要的通信机制，一端投递，一端接收，是一种间接消息传递机制，eg:ls|grep fork</p><p>特点</p><ul><li>单向通信，缓冲区满时阻塞</li><li>有且仅有一个输入和输出端口</li><li>数据不带类型，即字节流</li><li>基于Unix文件描述符使用</li></ul><p>优点：实现简单，对于简单场景有效<br>问题：</p><ol><li>缺少消息类型，需要接受者进行解析</li><li>缓冲区大小预先分配且固定</li><li>只能单向通信</li><li>只能最多支持两个进程通信</li></ol><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>带类型的消息传递，以链表形式组织消息 eg:Protobuf(<a href="https://developers.google.cn/protocol-buffers/">https://developers.google.cn/protocol-buffers/</a>)</p><ul><li>任何有权限的进程都可以访问队列，读取，写入</li><li>支持异步通信</li></ul><p>消息的格式：类型+数据（类型使用一个整型表示，由用户自定义）<br>消息队列的组织：FIFO（先进先出原则）<br>允许按照消息类型查询</p><h3 id="管道VS-消息队列"><a href="#管道VS-消息队列" class="headerlink" title="管道VS.消息队列"></a>管道VS.消息队列</h3><p>缓冲区设计</p><ul><li>消息队列：链表组织，动态分配资源，可以设置大上限</li><li>管道：固定缓冲区间，分配过大浪费</li></ul><p>消息格式</p><ul><li>消息队列：带类型的数据</li><li>管道：数据（字节流）</li></ul><p>链接上的进程通信</p><ul><li>消息队列：多个发送者和接受者</li><li>管道：两个端口</li></ul><p>消息管理</p><ul><li>消息队列：FIFO+基于类型查询</li><li>管道：FIFO</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MultiCoreDispatchStrategy</title>
      <link href="/2024/05/23/MultiCoreDispatchStrategy/"/>
      <url>/2024/05/23/MultiCoreDispatchStrategy/</url>
      
        <content type="html"><![CDATA[<h2 id="多核调度策略"><a href="#多核调度策略" class="headerlink" title="多核调度策略"></a>多核调度策略</h2><h3 id="多核下的负载负担"><a href="#多核下的负载负担" class="headerlink" title="多核下的负载负担"></a>多核下的负载负担</h3><p>考虑的问题 ：</p><ul><li>同一个进程的线程具有依赖关系 eg:GCC编译a.out文件</li></ul><p>解决方案 :</p><ul><li><p>协同调度：整体同步并行(Bulk Synchrinius Parallelism,BSP)计算模型，没有依赖关系的并行执行，有依赖关系的等待下一轮运行</p><p>使用场景 ：机器学习，图计算，分布式数据处理平台</p></li><li><p>群组调度（Cang Scheduling）:没有依赖关系的任务分在同一组，以组为单位进行调度</p><p>A B C D 内部没有依赖关系</p></li></ul><p>额外考虑的因素：</p><ul><li>一个进程的不同线程可以在不同CPU上执行，需要尽量让同一个进程的不同线程在同一个逻辑核心运行</li><li>任务在CPU核心间频繁切换对缓存不友好</li></ul><h3 id="缓存友好型调度：两级调度"><a href="#缓存友好型调度：两级调度" class="headerlink" title="缓存友好型调度：两级调度"></a>缓存友好型调度：两级调度</h3><ul><li><p>缺点：CPU负载不均衡</p></li><li><p>优化：</p><ul><li>每个任务特点不同，不能用任务数量代表真实负载</li><li>追踪CPU的负载情况</li><li>将任务从高负载的CPU迁移到低负载CPU</li></ul></li><li><p>负载追踪</p><ul><li>以运行队列为粒度追踪负载：队列长的负载高，迁移那个任务不知道，不够精确</li><li>以调度实体为粒度追踪负载：Per Entity Load Tracking（PELT）：记录每个负载实体对于负载的贡献（有多长时间在运行）    </li></ul></li></ul><h2 id="调度进阶机制"><a href="#调度进阶机制" class="headerlink" title="调度进阶机制"></a>调度进阶机制</h2><h3 id="处理器亲和性（processor-affinity）"><a href="#处理器亲和性（processor-affinity）" class="headerlink" title="处理器亲和性（processor affinity）"></a>处理器亲和性（processor affinity）</h3><p>不同物理内核之间的通信速度不同，操作系统允许程序主动选择使用哪个逻辑核心运行</p><h2 id="现代Linux调度器"><a href="#现代Linux调度器" class="headerlink" title="现代Linux调度器"></a>现代Linux调度器</h2><ul><li>现代处理器的大小核设计（高性能核，省电核）</li><li>CPU的能耗模型<br>  $ W&#x3D;\frac {1}{2}Vf^2 $</li><li>频率降低，处理器速度变慢，性能下降</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/04/30/hello-world/"/>
      <url>/2024/04/30/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
